<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°æ™ºæœåŠ¡å™¨æµ‹è¯•é¡µé¢</title>
    <style>
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        .section h2 {
            margin-top: 0;
            color: #444;
            font-size: 18px;
        }
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background-color: #4285f4;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #3367d6;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #serverUrl {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .message-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        #messageInput {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        #nfcCardId {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .conversation {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: white;
        }
        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 80%;
        }
        .user {
            background-color: #e2f2ff;
            margin-left: auto;
            margin-right: 10px;
            text-align: right;
        }
        .server {
            background-color: #f0f0f0;
            margin-right: auto;
            margin-left: 10px;
        }
        .status {
            color: #666;
            font-style: italic;
            text-align: center;
            margin-bottom: 10px;
        }
        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .audio-visualizer {
            height: 60px;
            width: 100%;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }
        .record-button {
            background-color: #db4437;
        }
        .record-button:hover {
            background-color: #c53929;
        }
        .record-button.recording {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { background-color: #db4437; }
            50% { background-color: #ff6659; }
            100% { background-color: #db4437; }
        }
        #logContainer {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            font-family: monospace;
            height: 150px;
            overflow-y: auto;
        }
        .log-entry {
            margin: 5px 0;
            font-size: 12px;
        }
        .log-info { color: #333; }
        .log-error { color: #db4437; }
        .log-success { color: #0f9d58; }
        .info-box {
            background-color: #e8f4ff;
            border-left: 4px solid #4285f4;
            width: auto;
            display: none;
            margin: 10px 0;
            padding: 10px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .script-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .script-loaded { background-color: #0f9d58; }
        .script-loading { background-color: #f4b400; }
        .script-error { background-color: #db4437; }
        
        .script-list {
            margin: 10px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        
        /* çŠ¶æ€æ¶ˆæ¯æ ·å¼ */
        #scriptStatus {
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        #scriptStatus.success {
            background-color: #e6f4ea;
            color: #0f9d58;
            border-left: 4px solid #0f9d58;
        }
        
        #scriptStatus.error {
            background-color: #fce8e6;
            color: #db4437;
            border-left: 4px solid #db4437;
        }
        
        #scriptStatus.warning {
            background-color: #fef7e0;
            color: #f4b400;
            border-left: 4px solid #f4b400;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>å°æ™ºæœåŠ¡å™¨æµ‹è¯•é¡µé¢</h1>
        
        <div id="scriptStatus" class="info-box"></div>
        
        <div class="section">
            <h2>WebSocketè¿æ¥</h2>
            <div class="control-panel">
                <input type="text" id="serverUrl" value="ws://localhost:8000" placeholder="WebSocketæœåŠ¡å™¨åœ°å€">
                <button id="connectButton">è¿æ¥</button>
                <button id="disconnectButton" disabled>æ–­å¼€</button>
                <button id="authTestButton">æµ‹è¯•è®¤è¯</button>
            </div>
            <div id="connectionStatus" class="status">æœªè¿æ¥</div>
        </div>
        
        <div class="section">
            <h2>æ–‡æœ¬æ¶ˆæ¯</h2>
            <div class="message-input">
                <input type="text" id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." disabled>
                <button id="sendTextButton" disabled>å‘é€</button>
            </div>
        </div>
        
        <div class="section">
            <h2>NFCå¡ç‰‡æ¨¡æ‹Ÿ</h2>
            <div class="message-input">
                <input type="text" id="nfcCardId" placeholder="è¾“å…¥NFCå¡ç‰‡ID..." value="ABCD1234EFGH5678" disabled>
                <button id="sendNfcButton" disabled>æ¨¡æ‹ŸNFCå¡ç‰‡</button>
            </div>
        </div>
        
        <div class="section">
            <h2>è¯­éŸ³æ¶ˆæ¯</h2>
            <div class="audio-controls">
                <button id="recordButton" class="record-button" disabled>å¼€å§‹å½•éŸ³</button>
                <button id="stopButton" disabled>åœæ­¢å½•éŸ³å¹¶å‘é€</button>
            </div>
            <canvas id="audioVisualizer" class="audio-visualizer"></canvas>
        </div>
        
        <div class="section">
            <h2>ä¼šè¯è®°å½•</h2>
            <div id="conversation" class="conversation"></div>
        </div>
        
        <div id="logContainer">
            <div class="log-entry log-info">å‡†å¤‡å°±ç»ªï¼Œè¯·è¿æ¥æœåŠ¡å™¨å¼€å§‹æµ‹è¯•...</div>
        </div>
    </div>

    <!-- Opusè§£ç åº“ -->
    <script src="libopus.js"></script>
    
    <script>
        // éœ€è¦åŠ è½½çš„è„šæœ¬åˆ—è¡¨ - ç§»é™¤Opusä¾èµ–
        const scriptFiles = [];
        
        // è„šæœ¬åŠ è½½çŠ¶æ€
        const scriptStatus = {
            loading: 0,
            loaded: 0,
            failed: 0,
            total: scriptFiles.length
        };
        
        // æ£€æŸ¥Opusåº“æ˜¯å¦å·²åŠ è½½
        function checkOpusLoaded() {
            // setTimeout(() => {
                try {
                    // æ£€æŸ¥Moduleæ˜¯å¦å­˜åœ¨ï¼ˆæœ¬åœ°åº“å¯¼å‡ºçš„å…¨å±€å˜é‡ï¼‰
                    if (typeof Module === 'undefined') {
                        throw new Error('Opusåº“æœªåŠ è½½ï¼ŒModuleå¯¹è±¡ä¸å­˜åœ¨');
                    }
                    
                    // å°è¯•å…ˆä½¿ç”¨Module.instanceï¼ˆlibopus.jsæœ€åä¸€è¡Œå¯¼å‡ºæ–¹å¼ï¼‰
                    if (typeof Module.instance !== 'undefined' && typeof Module.instance._opus_decoder_get_size === 'function') {
                        // ä½¿ç”¨Module.instanceå¯¹è±¡æ›¿æ¢å…¨å±€Moduleå¯¹è±¡
                        window.ModuleInstance = Module.instance;
                        log('Opusåº“åŠ è½½æˆåŠŸï¼ˆä½¿ç”¨Module.instanceï¼‰', 'success');
                        updateScriptStatus('Opusåº“åŠ è½½æˆåŠŸ', 'success');
                        
                        // 3ç§’åéšè—çŠ¶æ€
                        setTimeout(() => {
                            const statusElement = document.getElementById('scriptStatus');
                            if (statusElement) statusElement.style.display = 'none';
                        }, 3000);
                        return;
                    }
                    
                    // å¦‚æœæ²¡æœ‰Module.instanceï¼Œæ£€æŸ¥å…¨å±€Moduleå‡½æ•°
                    if (typeof Module._opus_decoder_get_size === 'function') {
                        window.ModuleInstance = Module;
                        log('Opusåº“åŠ è½½æˆåŠŸï¼ˆä½¿ç”¨å…¨å±€Moduleï¼‰', 'success');
                        updateScriptStatus('Opusåº“åŠ è½½æˆåŠŸ', 'success');
                        
                        // 3ç§’åéšè—çŠ¶æ€
                        setTimeout(() => {
                            const statusElement = document.getElementById('scriptStatus');
                            if (statusElement) statusElement.style.display = 'none';
                        }, 3000);
                        return;
                    }
                    
                    throw new Error('Opusè§£ç å‡½æ•°æœªæ‰¾åˆ°ï¼Œå¯èƒ½Moduleç»“æ„ä¸æ­£ç¡®');
                } catch (err) {
                    log(`Opusåº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥libopus.jsæ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”æ­£ç¡®: ${err.message}`, 'error');
                    updateScriptStatus('Opusåº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥libopus.jsæ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”æ­£ç¡®', 'error');
                }
            // }, 1000); // å»¶è¿Ÿ1ç§’æ£€æŸ¥ï¼Œç¡®ä¿è„šæœ¬æœ‰æ—¶é—´åŠ è½½
        }
        
        // æ›´æ–°è„šæœ¬çŠ¶æ€æ˜¾ç¤º
        function updateScriptStatus(message, type) {
            const statusElement = document.getElementById('scriptStatus');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `script-status ${type}`;
                statusElement.style.display = 'block';
                statusElement.style.width = 'auto';
            }
        }
        
        // å…¨å±€å˜é‡
        let websocket = null;
        let mediaRecorder = null;
        let audioContext = null;
        let analyser = null;
        let audioChunks = [];
        let isRecording = false;
        let visualizerCanvas = document.getElementById('audioVisualizer');
        let visualizerContext = visualizerCanvas.getContext('2d');
        let audioQueue = [];
        let isPlaying = false;
        let opusDecoder = null; // Opusè§£ç å™¨
        let visualizationRequest = null; // åŠ¨ç”»å¸§è¯·æ±‚ID
        
        // éŸ³é¢‘æµç¼“å†²ç›¸å…³
        let audioBuffers = []; // ç”¨äºå­˜å‚¨æ¥æ”¶åˆ°çš„æ‰€æœ‰éŸ³é¢‘æ•°æ®
        let totalAudioSize = 0; // è·Ÿè¸ªç´¯ç§¯çš„éŸ³é¢‘å¤§å°
        
        // DOMå…ƒç´ 
        const connectButton = document.getElementById('connectButton');
        const disconnectButton = document.getElementById('disconnectButton');
        const serverUrlInput = document.getElementById('serverUrl');
        const connectionStatus = document.getElementById('connectionStatus');
        const messageInput = document.getElementById('messageInput');
        const sendTextButton = document.getElementById('sendTextButton');
        const nfcCardIdInput = document.getElementById('nfcCardId');
        const sendNfcButton = document.getElementById('sendNfcButton');
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const conversationDiv = document.getElementById('conversation');
        const logContainer = document.getElementById('logContainer');
        
        // æ—¥å¿—å‡½æ•°
        function log(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (type === 'error') {
                logEntry.style.color = 'red';
            } else if (type === 'debug') {
                logEntry.style.color = 'gray';
                return;
            } else if (type === 'warning') {
                logEntry.style.color = 'orange';
            } else if (type === 'success') {
                logEntry.style.color = 'green';
            } else {
                logEntry.style.color = 'black';
            }
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // åˆå§‹åŒ–å¯è§†åŒ–å™¨
        function initVisualizer() {
            visualizerCanvas.width = visualizerCanvas.clientWidth;
            visualizerCanvas.height = visualizerCanvas.clientHeight;
            visualizerContext.fillStyle = '#fafafa';
            visualizerContext.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
        }
        
        // ç»˜åˆ¶éŸ³é¢‘å¯è§†åŒ–æ•ˆæœ
        function drawVisualizer(dataArray) {
            visualizationRequest = requestAnimationFrame(() => drawVisualizer(dataArray));
            
            if (!isRecording) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            visualizerContext.fillStyle = '#fafafa';
            visualizerContext.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            
            const barWidth = (visualizerCanvas.width / dataArray.length) * 2.5;
            let barHeight;
            let x = 0;
            
            for (let i = 0; i < dataArray.length; i++) {
                barHeight = dataArray[i] / 2;
                
                visualizerContext.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                visualizerContext.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }
        
        // æ·»åŠ æ¶ˆæ¯åˆ°ä¼šè¯è®°å½•
        function addMessage(text, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'server'}`;
            messageDiv.textContent = text;
            conversationDiv.appendChild(messageDiv);
            conversationDiv.scrollTop = conversationDiv.scrollHeight;
        }
        
      
        // æ’­æ”¾OpuséŸ³é¢‘æ•°æ®
        function playOpusData(opusBuffers) {
            if (!opusBuffers || opusBuffers.length === 0) {
                log('æ— æ•ˆçš„Opusæ•°æ®ï¼Œæ— æ³•æ’­æ”¾', 'warning');
                return;
            }
            
            if (isPlaying) {
                // å·²ç»åœ¨æ’­æ”¾ï¼ŒåŠ å…¥é˜Ÿåˆ—
                audioQueue.push(opusBuffers);
                log(`éŸ³é¢‘æ·»åŠ åˆ°é˜Ÿåˆ—ï¼Œå½“å‰é˜Ÿåˆ—é•¿åº¦: ${audioQueue.length}`, 'debug');
                return;
            }
            
            isPlaying = true;
            
            try {
                // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å­˜åœ¨
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });
                    log('åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡ï¼Œé‡‡æ ·ç‡: 16000Hz', 'debug');
                }
                
                // ç¡®ä¿è§£ç å™¨å·²åˆå§‹åŒ–
                if (!opusDecoder) {
                    try {
                        // æ£€æŸ¥ModuleInstanceæ˜¯å¦å­˜åœ¨ï¼ˆæœ¬åœ°åº“å¯¼å‡ºçš„å…¨å±€å˜é‡ï¼‰
                        if (typeof window.ModuleInstance === 'undefined') {
                            if (typeof Module !== 'undefined') {
                                // å°è¯•ä½¿ç”¨å…¨å±€Module
                                window.ModuleInstance = Module;
                                log('ä½¿ç”¨å…¨å±€Moduleä½œä¸ºModuleInstance', 'info');
                            } else {
                                throw new Error('Opusåº“æœªåŠ è½½ï¼ŒModuleInstanceå’ŒModuleå¯¹è±¡éƒ½ä¸å­˜åœ¨');
                            }
                        }
                        
                        // åˆå§‹åŒ–Opusè§£ç å™¨ - 16kHzé‡‡æ ·ç‡ï¼Œå•å£°é“
                        opusDecoder = {
                            channels: 1,
                            rate: 16000,
                            frameSize: 960, // 60ms @ 16kHz = 60 * 16 = 960 samples
                            frameDuration: 60, // 60mså¸§æ—¶é•¿
                            module: window.ModuleInstance, // ä¿å­˜æ¨¡å—å®ä¾‹çš„å¼•ç”¨
                            
                            // ä½¿ç”¨ModuleInstanceæä¾›çš„å‡½æ•°æ¥è§£ç 
                            decode_float: function(opusData) {
                                try {
                                    const mod = this.module; // ç®€å†™å¼•ç”¨
                                    
                                    // æ‰“å°è¾“å…¥æ•°æ®çš„å¤§å°
                                    log(`æ­£åœ¨è§£ç Opusæ•°æ®ï¼Œå¤§å°: ${opusData.length}å­—èŠ‚`, 'debug');
                                    
                                    // ä¸ºè¾“å…¥æ•°æ®åˆ†é…å†…å­˜
                                    const inputPtr = mod._malloc(opusData.length);
                                    mod.HEAPU8.set(opusData, inputPtr);
                                    
                                    // ä¸ºè¾“å‡ºPCMæ•°æ®åˆ†é…å†…å­˜ (æ¯ä¸ªæ ·æœ¬ä¸ºfloat)
                                    const pcmSamples = this.frameSize;
                                    const pcmPtr = mod._malloc(pcmSamples * 4); // 4å­—èŠ‚/float
                                    
                                    // åˆ›å»ºè§£ç å™¨å®ä¾‹
                                    const decoderSize = mod._opus_decoder_get_size(this.channels);
                                    log(`Opusè§£ç å™¨å¤§å°: ${decoderSize}å­—èŠ‚`, 'debug');
                                    
                                    const decoderPtr = mod._malloc(decoderSize);
                                    const err = mod._opus_decoder_init(decoderPtr, this.rate, this.channels);
                                    
                                    if (err < 0) {
                                        throw new Error(`Opusè§£ç å™¨åˆå§‹åŒ–å¤±è´¥: ${err}`);
                                    }
                                    
                                    // è§£ç éŸ³é¢‘å¸§
                                    const samplesDecoded = mod._opus_decode_float(
                                        decoderPtr,
                                        inputPtr,
                                        opusData.length,
                                        pcmPtr,
                                        this.frameSize,
                                        0 // ä¸ä½¿ç”¨FEC
                                    );
                                    
                                    if (samplesDecoded < 0) {
                                        throw new Error(`Opusè§£ç å¤±è´¥ï¼Œé”™è¯¯ç : ${samplesDecoded}`);
                                    }
                                    
                                    log(`è§£ç æˆåŠŸï¼Œè·å¾—${samplesDecoded}ä¸ªPCMæ ·æœ¬`, 'debug');
                                    
                                    // ä»å†…å­˜ä¸­å¤åˆ¶PCMæ•°æ®
                                    const pcmData = new Float32Array(samplesDecoded);
                                    for (let i = 0; i < samplesDecoded; i++) {
                                        pcmData[i] = mod.HEAPF32[pcmPtr/4 + i];
                                    }
                                    
                                    // é‡Šæ”¾å†…å­˜
                                    mod._free(inputPtr);
                                    mod._free(pcmPtr);
                                    mod._free(decoderPtr);
                                    
                                    return pcmData;
                                } catch (err) {
                                    log(`è§£ç è¿‡ç¨‹ä¸­å‡ºé”™: ${err.message}`, 'error');
                                    return new Float32Array(0);
                                }
                            }
                        };
                        
                        log('Opusè§£ç å™¨åˆå§‹åŒ–æˆåŠŸ', 'success');
                    } catch (err) {
                        log(`Opusè§£ç å™¨åˆå§‹åŒ–å¤±è´¥: ${err.message}ï¼Œå°è¯•ä½¿ç”¨ç®€å•æ’­æ”¾`, 'error');
                        // å›é€€åˆ°ç®€å•æ’­æ”¾
                        simpleFallbackPlay(opusBuffers);
                        isPlaying = false;
                        return;
                    }
                }
                
                // è§£ç æ‰€æœ‰Opuså¸§
                let pcmData = [];
                let successCount = 0;
                
                for (let i = 0; i < opusBuffers.length; i++) {
                    try {
                        const opusBuffer = opusBuffers[i];
                        // ç¡®ä¿è¿™æ˜¯Uint8Array
                        const opusArray = opusBuffer instanceof Uint8Array ? 
                                          opusBuffer : new Uint8Array(opusBuffer);
                        
                        // è§£ç Opuså¸§ä¸ºPCMæ•°æ®
                        const decoded = opusDecoder.decode_float(opusArray);
                        if (decoded && decoded.length > 0) {
                            pcmData.push(decoded);
                            successCount++;
                        }
                    } catch (error) {
                        log(`Opuså¸§ #${i+1} è§£ç é”™è¯¯: ${error.message}`, 'error');
                    }
                }
                
                log(`è§£ç å®Œæˆï¼ŒæˆåŠŸ: ${successCount}/${opusBuffers.length} å¸§`, 'debug');
                
                if (pcmData.length === 0) {
                    log('æ²¡æœ‰æˆåŠŸè§£ç çš„å¸§ï¼Œå°è¯•ä½¿ç”¨ç®€å•æ’­æ”¾', 'warning');
                    simpleFallbackPlay(opusBuffers);
                    isPlaying = false;
                    return;
                }
                
                // è¿æ¥æ‰€æœ‰PCMæ•°æ®
                const totalSamples = pcmData.reduce((acc, arr) => acc + arr.length, 0);
                log(`æ€»å…±è§£ç å‡º ${totalSamples} ä¸ªPCMæ ·æœ¬`, 'debug');
                
                const combinedPCM = new Float32Array(totalSamples);
                
                let offset = 0;
                for (const buffer of pcmData) {
                    combinedPCM.set(buffer, offset);
                    offset += buffer.length;
                }
                
                // ä½¿ç”¨Web Audio APIæ’­æ”¾PCMæ•°æ®
                const audioBuffer = audioContext.createBuffer(1, combinedPCM.length, 16000);
                audioBuffer.getChannelData(0).set(combinedPCM);
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                
                source.onended = () => {
                    isPlaying = false;
                    log('éŸ³é¢‘æ’­æ”¾å®Œæˆ', 'debug');
                    
                    // æ’­æ”¾é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ª
                    if (audioQueue.length > 0) {
                        const nextBuffers = audioQueue.shift();
                        playOpusData(nextBuffers);
                    }
                };
                
                source.start();
                log(`å¼€å§‹æ’­æ”¾PCMéŸ³é¢‘ï¼Œæ—¶é•¿: ${(combinedPCM.length/16000).toFixed(2)}ç§’`, 'debug');
                
            } catch (error) {
                log(`æ’­æ”¾OpuséŸ³é¢‘é”™è¯¯: ${error.message}ï¼Œå°è¯•ä½¿ç”¨ç®€å•æ’­æ”¾`, 'error');
                simpleFallbackPlay(opusBuffers);
                isPlaying = false;
            }
        }
        
        // ç®€å•æ’­æ”¾å›é€€æ–¹æ¡ˆ
        function simpleFallbackPlay(opusBuffers) {
            try {
                log('ä½¿ç”¨ç®€å•æ’­æ”¾å›é€€æ–¹æ¡ˆ', 'warning');
                
                // åˆ›å»ºä¸€ä¸ªç®€å•çš„"æ»´"å£°ä½œä¸ºåé¦ˆ
                if (audioContext) {
                    const oscillator = audioContext.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4éŸ³
                    
                    const gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // è®¾ç½®éŸ³é‡ä¸º0.1
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2); // æ’­æ”¾0.2ç§’
                    
                    log('æ’­æ”¾æç¤ºéŸ³ä½œä¸ºéŸ³é¢‘æ’­æ”¾å¤±è´¥çš„åé¦ˆ', 'info');
                }
            } catch (error) {
                log(`ç®€å•æ’­æ”¾å›é€€æ–¹æ¡ˆä¹Ÿå¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // åˆå§‹åŒ–éŸ³é¢‘å½•åˆ¶å’Œå¤„ç† 
        async function initAudio() {
            try {
                // è¯·æ±‚éº¦å…‹é£æƒé™
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000,  // ç¡®ä¿16kHzé‡‡æ ·ç‡
                        channelCount: 1     // ç¡®ä¿å•å£°é“
                    }
                });
                log('å·²è·å–éº¦å…‹é£è®¿é—®æƒé™', 'success');
                
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,  // ç¡®ä¿é‡‡æ ·ç‡ä¸æœåŠ¡å™¨æœŸæœ›çš„ä¸€è‡´
                    latencyHint: 'interactive'
                });
                const source = audioContext.createMediaStreamSource(stream);
                
                // è·å–å®é™…éŸ³é¢‘è½¨é“è®¾ç½®
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    const settings = track.getSettings();
                    log(`å®é™…éº¦å…‹é£è®¾ç½® - é‡‡æ ·ç‡: ${settings.sampleRate || 'æœªçŸ¥'}Hz, å£°é“æ•°: ${settings.channelCount || 'æœªçŸ¥'}`, 'info');
                }
                
                // åˆ›å»ºåˆ†æå™¨ç”¨äºå¯è§†åŒ–
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                
                // å°è¯•åˆå§‹åŒ–MediaRecorderï¼ŒæŒ‰ä¼˜å…ˆçº§å°è¯•ä¸åŒç¼–ç é€‰é¡¹
                try {
                    // ä¼˜å…ˆå°è¯•ä½¿ç”¨Opusç¼–ç 
                    mediaRecorder = new MediaRecorder(stream, { 
                        mimeType: 'audio/webm;codecs=opus',
                        audioBitsPerSecond: 16000
                    });
                    log('å·²åˆå§‹åŒ–MediaRecorder (ä½¿ç”¨Opusç¼–ç )', 'success');
                    log(`é€‰æ‹©çš„ç¼–ç æ ¼å¼: ${mediaRecorder.mimeType}`, 'info');
                } catch (e1) {
                    try {
                        // å¦‚æœOpusä¸æ”¯æŒï¼Œå°è¯•MP3
                        mediaRecorder = new MediaRecorder(stream, { 
                            mimeType: 'audio/webm',
                            audioBitsPerSecond: 16000
                        });
                        log('å·²åˆå§‹åŒ–MediaRecorder (ä½¿ç”¨WebMæ ‡å‡†ç¼–ç ï¼ŒOpusä¸æ”¯æŒ)', 'warning');
                        log(`é€‰æ‹©çš„ç¼–ç æ ¼å¼: ${mediaRecorder.mimeType}`, 'info');
                    } catch (e2) {
                        try {
                            // å°è¯•å…¶ä»–å¤‡é€‰æ ¼å¼
                            mediaRecorder = new MediaRecorder(stream, { 
                                mimeType: 'audio/ogg;codecs=opus',
                                audioBitsPerSecond: 16000
                            });
                            log('å·²åˆå§‹åŒ–MediaRecorder (ä½¿ç”¨OGG+Opusç¼–ç )', 'warning');
                            log(`é€‰æ‹©çš„ç¼–ç æ ¼å¼: ${mediaRecorder.mimeType}`, 'info');
                        } catch (e3) {
                            // æœ€åä½¿ç”¨é»˜è®¤ç¼–ç 
                            mediaRecorder = new MediaRecorder(stream);
                            log(`å·²åˆå§‹åŒ–MediaRecorder (ä½¿ç”¨é»˜è®¤ç¼–ç : ${mediaRecorder.mimeType})`, 'warning');
                        }
                    }
                }
                
                // å¤„ç†å½•åˆ¶çš„æ•°æ®
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                // å½•åˆ¶ç»“æŸåå¤„ç†æ•°æ®
                mediaRecorder.onstop = async () => {
                    // åœæ­¢å¯è§†åŒ–
                    if (visualizationRequest) {
                        cancelAnimationFrame(visualizationRequest);
                        visualizationRequest = null;
                    }
                    
                    log(`å½•éŸ³ç»“æŸï¼Œå·²æ”¶é›†çš„éŸ³é¢‘å—æ•°é‡: ${audioChunks.length}`, 'info');
                    if (audioChunks.length === 0) {
                        log('è­¦å‘Šï¼šæ²¡æœ‰æ”¶é›†åˆ°ä»»ä½•éŸ³é¢‘æ•°æ®ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£æ˜¯å¦å·¥ä½œæ­£å¸¸', 'error');
                        return;
                    }
                    
                    // åˆ›å»ºå®Œæ•´çš„å½•éŸ³blob
                    const blob = new Blob(audioChunks, { type: audioChunks[0].type });
                    log(`å·²åˆ›å»ºéŸ³é¢‘Blobï¼ŒMIMEç±»å‹: ${audioChunks[0].type}ï¼Œå¤§å°: ${(blob.size / 1024).toFixed(2)} KB`, 'info');
                    
                    // ä¿å­˜åŸå§‹å—ï¼Œä»¥é˜²æ¸…ç©ºåéœ€è¦è°ƒè¯•
                    const chunks = [...audioChunks];
                    audioChunks = [];
                    
                    try {
                        // å°†blobè½¬æ¢ä¸ºArrayBuffer
                        const arrayBuffer = await blob.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        
                        log(`å·²è½¬æ¢ä¸ºUint8Arrayï¼Œå‡†å¤‡å‘é€ï¼Œå¤§å°: ${(arrayBuffer.byteLength / 1024).toFixed(2)} KB`, 'info');
                        
                        // æ£€æŸ¥WebSocketçŠ¶æ€
                        if (!websocket) {
                            log('é”™è¯¯ï¼šWebSocketè¿æ¥ä¸å­˜åœ¨', 'error');
                            return;
                        }
                        
                        if (websocket.readyState !== WebSocket.OPEN) {
                            log(`é”™è¯¯ï¼šWebSocketè¿æ¥æœªæ‰“å¼€ï¼Œå½“å‰çŠ¶æ€: ${websocket.readyState}`, 'error');
                            return;
                        }
                        
                        // ç›´æ¥å‘é€äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ® - è¿™æ˜¯æœ€ç®€å•æœ‰æ•ˆçš„æ–¹å¼
                        try {
                            // æ³¨æ„ï¼šå¼€å§‹å’Œç»“æŸæ¶ˆæ¯å·²åœ¨å½•éŸ³å¼€å§‹å’Œç»“æŸæ—¶å‘é€
                            // è¿™é‡Œåªéœ€è¦å‘é€éŸ³é¢‘æ•°æ®
                            await new Promise(resolve => setTimeout(resolve, 50));
                            
                            // å¤„ç†WebMå®¹å™¨æ ¼å¼ï¼Œæå–çº¯Opusæ•°æ®
                            // æœåŠ¡å™¨ä½¿ç”¨opuslib_next.Decoderï¼Œéœ€è¦çº¯Opuså¸§
                            log('æ­£åœ¨å¤„ç†éŸ³é¢‘æ•°æ®ï¼Œæå–çº¯Opuså¸§...', 'info');
                            const opusData = extractOpusFrames(uint8Array);
                            
                            // è®°å½•Opusæ•°æ®å¤§å°
                            log(`å·²æå–Opusæ•°æ®ï¼Œå¤§å°: ${(opusData.byteLength / 1024).toFixed(2)} KB`, 'info');
                            
                            // å‘é€éŸ³é¢‘æ¶ˆæ¯ç¬¬äºŒæ­¥ï¼šäºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®
                            websocket.send(opusData);
                            log(`å·²å‘é€OpuséŸ³é¢‘æ•°æ®: ${(opusData.byteLength / 1024).toFixed(2)} KB`, 'success');
                        } catch (error) {
                            log(`éŸ³é¢‘æ•°æ®å‘é€å¤±è´¥: ${error.message}`, 'error');
                            
                            // å°è¯•ä½¿ç”¨base64ç¼–ç ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
                            try {
                                log('å°è¯•ä½¿ç”¨base64ç¼–ç æ–¹å¼å‘é€...', 'info');
                                const base64Data = arrayBufferToBase64(arrayBuffer);
                                const audioDataMessage = {
                                    type: 'audio',
                                    action: 'data',
                                    format: 'opus',
                                    sample_rate: 16000,
                                    channels: 1,
                                    mime_type: chunks[0].type,
                                    encoding: 'base64',
                                    data: base64Data
                                };
                                websocket.send(JSON.stringify(audioDataMessage));
                                log(`å·²ä½¿ç”¨base64ç¼–ç å‘é€éŸ³é¢‘æ•°æ®: ${(arrayBuffer.byteLength / 1024).toFixed(2)} KB`, 'warning');
                            } catch (base64Error) {
                                log(`æ‰€æœ‰æ•°æ®å‘é€æ–¹å¼å‡å¤±è´¥: ${base64Error.message}`, 'error');
                            }
                        }
                    } catch (error) {
                        log(`å¤„ç†å½•éŸ³æ•°æ®é”™è¯¯: ${error.message}`, 'error');
                    }
                };
                
                // å°è¯•åˆå§‹åŒ–Opusè§£ç å™¨
                try {
                    // æ£€æŸ¥ModuleInstanceæ˜¯å¦å­˜åœ¨ï¼ˆæœ¬åœ°åº“å¯¼å‡ºçš„å…¨å±€å˜é‡ï¼‰
                    if (typeof window.ModuleInstance === 'undefined') {
                        throw new Error('Opusåº“æœªåŠ è½½ï¼ŒModuleInstanceå¯¹è±¡ä¸å­˜åœ¨');
                    }
                    
                    // ç®€å•æµ‹è¯•ModuleInstanceæ˜¯å¦å¯ç”¨
                    if (typeof window.ModuleInstance._opus_decoder_get_size === 'function') {
                        const testSize = window.ModuleInstance._opus_decoder_get_size(1);
                        log(`Opusè§£ç å™¨æµ‹è¯•æˆåŠŸï¼Œè§£ç å™¨å¤§å°: ${testSize} å­—èŠ‚`, 'success');
                    } else {
                        throw new Error('Opusè§£ç å‡½æ•°æœªæ‰¾åˆ°');
                    }
                } catch (err) {
                    log(`Opusè§£ç å™¨åˆå§‹åŒ–è­¦å‘Š: ${err.message}ï¼Œå°†åœ¨éœ€è¦æ—¶é‡è¯•`, 'warning');
                }
                
                log('éŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', 'success');
                return true;
            } catch (error) {
                log(`éŸ³é¢‘åˆå§‹åŒ–é”™è¯¯: ${error.message}`, 'error');
                return false;
            }
        }
        
        // å¼€å§‹å½•éŸ³
        function startRecording() {
            if (isRecording) return;
            
            try {
                // æœ€å°å½•éŸ³æ—¶é•¿æç¤º
                log('è¯·è‡³å°‘å½•åˆ¶1-2ç§’é’Ÿçš„éŸ³é¢‘ï¼Œç¡®ä¿é‡‡é›†åˆ°è¶³å¤Ÿæ•°æ®', 'info');
                
                // è·å–æœåŠ¡å™¨ç±»å‹ - ä»URLåˆ¤æ–­
                const serverUrl = serverUrlInput.value.trim();
                let isXiaozhiNative = false;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å°æ™ºåŸç”ŸæœåŠ¡å™¨ (æ ¹æ®URLç‰¹å¾åˆ¤æ–­)
                if (serverUrl.includes('xiaozhi') || serverUrl.includes('localhost') || serverUrl.includes('127.0.0.1')) {
                    isXiaozhiNative = true;
                    log('æ£€æµ‹åˆ°å°æ™ºåŸç”ŸæœåŠ¡å™¨ï¼Œä½¿ç”¨æ ‡å‡†listenåè®®', 'info');
                }
                
                // ä½¿ç”¨ç›´æ¥PCMå½•éŸ³å’Œlibopusç¼–ç çš„æ–¹å¼
                startDirectRecording();
            } catch (error) {
                log(`å½•éŸ³å¯åŠ¨é”™è¯¯: ${error.message}`, 'error');
            }
        }
        
        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (!isRecording) return;
            
            try {
                // ä½¿ç”¨ç›´æ¥PCMå½•éŸ³åœæ­¢
                stopDirectRecording();
            } catch (error) {
                log(`åœæ­¢å½•éŸ³é”™è¯¯: ${error.message}`, 'error');
            }
        }
        
        // è¿æ¥WebSocketæœåŠ¡å™¨
        function connectToServer() {
            const url = serverUrlInput.value.trim();
            if (url === '') return;
            
            try {
                // æ£€æŸ¥URLæ ¼å¼
                if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                    log('URLæ ¼å¼é”™è¯¯ï¼Œå¿…é¡»ä»¥ws://æˆ–wss://å¼€å¤´', 'error');
                    return;
                }
                
                // ä½¿ç”¨è‡ªå®šä¹‰WebSocketå®ç°ä»¥æ·»åŠ è®¤è¯å¤´ä¿¡æ¯
                // æ³¨æ„ï¼šæµè§ˆå™¨åŸç”ŸWebSocketä¸æ”¯æŒè‡ªå®šä¹‰å¤´ï¼Œéœ€è¦é€šè¿‡æœåŠ¡å™¨æ·»åŠ ä¸€ä¸ªä»£ç†å±‚
                // ä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡URLå‚æ•°æ¨¡æ‹Ÿè®¤è¯ä¿¡æ¯
                let connUrl = new URL(url);
                
                // æ·»åŠ è®¤è¯å‚æ•°
                connUrl.searchParams.append('device_id', 'web_test_device');
                connUrl.searchParams.append('device_mac', '00:11:22:33:44:55');
                
                log(`æ­£åœ¨è¿æ¥: ${connUrl.toString()}`, 'info');
                websocket = new WebSocket(connUrl.toString());
                
                // è®¾ç½®æ¥æ”¶äºŒè¿›åˆ¶æ•°æ®çš„ç±»å‹ä¸ºArrayBuffer
                websocket.binaryType = 'arraybuffer';
                
                websocket.onopen = async () => {
                    log(`å·²è¿æ¥åˆ°æœåŠ¡å™¨: ${url}`, 'success');
                    connectionStatus.textContent = 'å·²è¿æ¥';
                    connectionStatus.style.color = 'green';
                    
                    // è¿æ¥æˆåŠŸåå‘é€helloæ¶ˆæ¯
                    await sendHelloMessage();
                    
                    connectButton.disabled = true;
                    disconnectButton.disabled = false;
                    messageInput.disabled = false;
                    sendTextButton.disabled = false;
                    nfcCardIdInput.disabled = false;
                    sendNfcButton.disabled = false;
                    
                    const audioInitialized = await initAudio();
                    if (audioInitialized) {
                        recordButton.disabled = false;
                    }
                };
                
                websocket.onclose = () => {
                    log('å·²æ–­å¼€è¿æ¥', 'info');
                    connectionStatus.textContent = 'å·²æ–­å¼€';
                    connectionStatus.style.color = 'red';
                    
                    connectButton.disabled = false;
                    disconnectButton.disabled = true;
                    messageInput.disabled = true;
                    sendTextButton.disabled = true;
                    recordButton.disabled = true;
                    stopButton.disabled = true;
                    nfcCardIdInput.disabled = true;
                    sendNfcButton.disabled = true;
                };
                
                websocket.onerror = (error) => {
                    log(`WebSocketé”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                    connectionStatus.textContent = 'è¿æ¥é”™è¯¯';
                    connectionStatus.style.color = 'red';
                };
                
                websocket.onmessage = function(event) {
                    try {
                        // æ£€æŸ¥æ˜¯å¦ä¸ºæ–‡æœ¬æ¶ˆæ¯
                        if (typeof event.data === 'string') {
                            const message = JSON.parse(event.data);
                            
                            if (message.type === 'hello') {
                                log(`æœåŠ¡å™¨å›åº”ï¼š${message.message}`, 'info');
                            } else if (message.type === 'tts') {
                                // TTSçŠ¶æ€æ¶ˆæ¯
                                if (message.state === 'start') {
                                    log('æœåŠ¡å™¨å¼€å§‹å‘é€è¯­éŸ³', 'info');
                                } else if (message.state === 'sentence_start') {
                                    log(`æœåŠ¡å™¨å‘é€è¯­éŸ³æ®µ: ${message.text}`, 'info');
                                    // æ·»åŠ æ–‡æœ¬åˆ°ä¼šè¯è®°å½•
                                    if (message.text) {
                                        addMessage(message.text);
                                    }
                                } else if (message.state === 'sentence_end') {
                                    log(`è¯­éŸ³æ®µç»“æŸ: ${message.text}`, 'info');
                                } else if (message.state === 'stop') {
                                    log('æœåŠ¡å™¨è¯­éŸ³ä¼ è¾“ç»“æŸ', 'info');
                                    // ç»“æŸåæ›´æ–°UIçŠ¶æ€
                                    if (recordButton.disabled) {
                                        recordButton.disabled = false;
                                        recordButton.textContent = 'å¼€å§‹å½•éŸ³';
                                        recordButton.classList.remove('recording');
                                    }
                                }
                            } else if (message.type === 'audio') {
                                // éŸ³é¢‘æ§åˆ¶æ¶ˆæ¯
                                log(`æ”¶åˆ°éŸ³é¢‘æ§åˆ¶æ¶ˆæ¯: ${JSON.stringify(message)}`, 'info');
                            } else if (message.type === 'stt') {
                                // è¯­éŸ³è¯†åˆ«ç»“æœ
                                log(`è¯†åˆ«ç»“æœ: ${message.text}`, 'info');
                                // æ·»åŠ è¯†åˆ«ç»“æœåˆ°ä¼šè¯è®°å½•
                                addMessage(`[è¯­éŸ³è¯†åˆ«] ${message.text}`, true);
                            } else if (message.type === 'llm') {
                                // å¤§æ¨¡å‹å›å¤
                                log(`å¤§æ¨¡å‹å›å¤: ${message.text}`, 'info');
                                // æ·»åŠ å¤§æ¨¡å‹å›å¤åˆ°ä¼šè¯è®°å½•
                                if (message.text && message.text !== 'ğŸ˜Š') {
                                    addMessage(message.text);
                                }
                            } else if (message.type === 'nfc_card_response') {
                                // NFCå¡ç‰‡å“åº”
                                log(`NFCå¡ç‰‡å“åº”: ${message.status}`, message.status === 'success' ? 'success' : 'error');
                                if (message.content) {
                                    addMessage(`[NFCå¡ç‰‡å†…å®¹] ${message.content}`);
                                } else if (message.message) {
                                    addMessage(`[NFCå¡ç‰‡é”™è¯¯] ${message.message}`);
                                }
                            } else {
                                // æœªçŸ¥æ¶ˆæ¯ç±»å‹
                                log(`æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${message.type}`, 'info');
                                addMessage(JSON.stringify(message, null, 2));
                            }
                        } else {
                            // å¤„ç†äºŒè¿›åˆ¶æ•°æ® - å…¼å®¹å¤šç§äºŒè¿›åˆ¶æ ¼å¼
                            handleBinaryMessage(event.data);
                        }
                    } catch (error) {
                        log(`WebSocketæ¶ˆæ¯å¤„ç†é”™è¯¯: ${error.message}`, 'error');
                        // éJSONæ ¼å¼æ–‡æœ¬æ¶ˆæ¯ç›´æ¥æ˜¾ç¤º
                        if (typeof event.data === 'string') {
                            addMessage(event.data);
                        }
                    }
                };
                
                connectionStatus.textContent = 'æ­£åœ¨è¿æ¥...';
                connectionStatus.style.color = 'orange';
            } catch (error) {
                log(`è¿æ¥é”™è¯¯: ${error.message}`, 'error');
                connectionStatus.textContent = 'è¿æ¥å¤±è´¥';
            }
        }
        
        // å‘é€helloæ¡æ‰‹æ¶ˆæ¯
        async function sendHelloMessage() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
            
            try {
                // è®¾ç½®è®¾å¤‡ä¿¡æ¯
                const helloMessage = {
                    type: 'hello',
                    device_id: 'web_test_device',
                    device_name: 'Webæµ‹è¯•è®¾å¤‡',
                    device_mac: '00:11:22:33:44:55',
                    token: 'your-token1' // ä½¿ç”¨config.yamlä¸­é…ç½®çš„token
                };
                
                log('å‘é€helloæ¡æ‰‹æ¶ˆæ¯', 'info');
                websocket.send(JSON.stringify(helloMessage));
                
                // ç­‰å¾…æœåŠ¡å™¨å“åº”
                return new Promise(resolve => {
                    // 5ç§’è¶…æ—¶
                    const timeout = setTimeout(() => {
                        log('ç­‰å¾…helloå“åº”è¶…æ—¶', 'error');
                        log('æç¤º: è¯·å°è¯•ç‚¹å‡»"æµ‹è¯•è®¤è¯"æŒ‰é’®è¿›è¡Œè¿æ¥æ’æŸ¥', 'info');
                        resolve(false);
                    }, 5000);
                    
                    // ä¸´æ—¶ç›‘å¬ä¸€æ¬¡æ¶ˆæ¯ï¼Œæ¥æ”¶helloå“åº”
                    const onMessageHandler = (event) => {
                        try {
                            const response = JSON.parse(event.data);
                            if (response.type === 'hello' && response.session_id) {
                                log(`æœåŠ¡å™¨æ¡æ‰‹æˆåŠŸï¼Œä¼šè¯ID: ${response.session_id}`, 'success');
                                clearTimeout(timeout);
                                websocket.removeEventListener('message', onMessageHandler);
                                resolve(true);
                            }
                        } catch (e) {
                            // å¿½ç•¥éJSONæ¶ˆæ¯
                        }
                    };
                    
                    websocket.addEventListener('message', onMessageHandler);
                });
            } catch (error) {
                log(`å‘é€helloæ¶ˆæ¯é”™è¯¯: ${error.message}`, 'error');
                return false;
            }
        }
        
        // æ–­å¼€WebSocketè¿æ¥
        function disconnectFromServer() {
            if (!websocket) return;
            
            websocket.close();
            stopRecording();
        }
        
        // å‘é€æ–‡æœ¬æ¶ˆæ¯
        function sendTextMessage() {
            const message = messageInput.value.trim();
            if (message === '' || !websocket || websocket.readyState !== WebSocket.OPEN) return;
            
            try {
                // ç›´æ¥å‘é€listenæ¶ˆæ¯ï¼Œä¸éœ€è¦é‡å¤å‘é€hello
                const listenMessage = {
                    type: 'listen',
                    mode: 'manual',
                    state: 'detect',
                    text: message
                };
                
                websocket.send(JSON.stringify(listenMessage));
                addMessage(message, true);
                log(`å‘é€æ–‡æœ¬æ¶ˆæ¯: ${message}`, 'info');
                
                messageInput.value = '';
            } catch (error) {
                log(`å‘é€æ¶ˆæ¯é”™è¯¯: ${error.message}`, 'error');
            }
        }
        
        // å‘é€NFCå¡ç‰‡æ¶ˆæ¯
        function sendNfcCardMessage() {
            const cardId = nfcCardIdInput.value.trim();
            if (cardId === '' || !websocket || websocket.readyState !== WebSocket.OPEN) return;
            
            try {
                // æ„é€ NFCå¡ç‰‡æ¶ˆæ¯
                const nfcMessage = {
                    type: 'nfc_card_detected',
                    card_id: cardId
                };
                
                websocket.send(JSON.stringify(nfcMessage));
                log(`å‘é€NFCå¡ç‰‡æ¶ˆæ¯, å¡ç‰‡ID: ${cardId}`, 'info');
                addMessage(`[NFCå¡ç‰‡] ${cardId}`, true);
            } catch (error) {
                log(`å‘é€NFCå¡ç‰‡æ¶ˆæ¯é”™è¯¯: ${error.message}`, 'error');
            }
        }
        
        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initEventListeners() {
            connectButton.addEventListener('click', connectToServer);
            disconnectButton.addEventListener('click', disconnectFromServer);
            document.getElementById('authTestButton').addEventListener('click', testAuthentication);
            
            sendTextButton.addEventListener('click', sendTextMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendTextMessage();
            });
            
            sendNfcButton.addEventListener('click', sendNfcCardMessage);
            
            recordButton.addEventListener('click', startRecording);
            stopButton.addEventListener('click', stopRecording);
            
            window.addEventListener('resize', initVisualizer);
        }
        
        // æµ‹è¯•è®¤è¯
        async function testAuthentication() {
            log('å¼€å§‹æµ‹è¯•è®¤è¯...', 'info');
            
            // æ˜¾ç¤ºæœåŠ¡å™¨é…ç½®
            log('-------- æœåŠ¡å™¨è®¤è¯é…ç½®æ£€æŸ¥ --------', 'info');
            log('è¯·ç¡®è®¤config.yamlä¸­çš„authé…ç½®ï¼š', 'info');
            log('1. server.auth.enabled ä¸º false æˆ–æœåŠ¡å™¨å·²æ­£ç¡®é…ç½®è®¤è¯', 'info');
            log('2. å¦‚æœå¯ç”¨äº†è®¤è¯ï¼Œè¯·ç¡®è®¤ä½¿ç”¨äº†æ­£ç¡®çš„token', 'info');
            log('3. æˆ–è€…åœ¨allowed_devicesä¸­æ·»åŠ äº†æµ‹è¯•è®¾å¤‡MACï¼š00:11:22:33:44:55', 'info');
            
            const serverUrl = serverUrlInput.value.trim();
            if (!serverUrl) {
                log('è¯·è¾“å…¥æœåŠ¡å™¨åœ°å€', 'error');
                return;
            }
            
            // æµ‹è¯•è¿æ¥
            log('å°è¯•ä¸åŒè®¤è¯å‚æ•°çš„è¿æ¥ï¼š', 'info');
            
            // æµ‹è¯•1: æ— å‚æ•°è¿æ¥
            try {
                log('æµ‹è¯•1: å°è¯•æ— å‚æ•°è¿æ¥...', 'info');
                const ws1 = new WebSocket(serverUrl);
                
                ws1.onopen = () => {
                    log('æµ‹è¯•1æˆåŠŸ: æ— å‚æ•°å¯è¿æ¥ï¼ŒæœåŠ¡å™¨å¯èƒ½æ²¡æœ‰å¯ç”¨è®¤è¯', 'success');
                    ws1.close();
                };
                
                ws1.onerror = (error) => {
                    log('æµ‹è¯•1å¤±è´¥: æ— å‚æ•°è¿æ¥è¢«æ‹’ç»ï¼ŒæœåŠ¡å™¨å¯èƒ½å¯ç”¨äº†è®¤è¯', 'error');
                };
                
                // 5ç§’åå…³é—­æµ‹è¯•è¿æ¥
                setTimeout(() => {
                    if (ws1.readyState === WebSocket.CONNECTING || ws1.readyState === WebSocket.OPEN) {
                        ws1.close();
                    }
                }, 5000);
            } catch (error) {
                log(`æµ‹è¯•1å‡ºé”™: ${error.message}`, 'error');
            }
            
            // æµ‹è¯•2: å¸¦å‚æ•°è¿æ¥
            setTimeout(async () => {
                try {
                    log('æµ‹è¯•2: å°è¯•å¸¦tokenå‚æ•°è¿æ¥...', 'info');
                    
                    let url = new URL(serverUrl);
                    url.searchParams.append('token', 'your-token1');
                    url.searchParams.append('device_id', 'web_test_device');
                    url.searchParams.append('device_mac', '00:11:22:33:44:55');
                    
                    const ws2 = new WebSocket(url.toString());
                    
                    ws2.onopen = () => {
                        log('æµ‹è¯•2æˆåŠŸ: å¸¦tokenå‚æ•°å¯è¿æ¥', 'success');
                        
                        // å°è¯•å‘é€helloæ¶ˆæ¯
                        const helloMsg = {
                            type: 'hello',
                            device_id: 'web_test_device',
                            device_mac: '00:11:22:33:44:55',
                            token: 'your-token1'
                        };
                        
                        ws2.send(JSON.stringify(helloMsg));
                        log('å·²å‘é€helloæµ‹è¯•æ¶ˆæ¯', 'info');
                        
                        // ç›‘å¬å“åº”
                        ws2.onmessage = (event) => {
                            try {
                                const response = JSON.parse(event.data);
                                if (response.type === 'hello' && response.session_id) {
                                    log(`æµ‹è¯•å®Œå…¨æˆåŠŸ! æ”¶åˆ°helloå“åº”ï¼Œä¼šè¯ID: ${response.session_id}`, 'success');
                                    ws2.close();
                                }
                            } catch (e) {
                                log(`æ”¶åˆ°éJSONå“åº”: ${event.data}`, 'info');
                            }
                        };
                        
                        // 5ç§’åå…³é—­
                        setTimeout(() => ws2.close(), 5000);
                    };
                    
                    ws2.onerror = (error) => {
                        log('æµ‹è¯•2å¤±è´¥: å¸¦tokenå‚æ•°è¿æ¥è¢«æ‹’ç»', 'error');
                        log('è¯·æ£€æŸ¥tokenæ˜¯å¦æ­£ç¡®ï¼Œæˆ–æœåŠ¡å™¨æ˜¯å¦æ¥å—URLå‚æ•°è®¤è¯', 'error');
                    };
                } catch (error) {
                    log(`æµ‹è¯•2å‡ºé”™: ${error.message}`, 'error');
                }
            }, 6000);
            
            log('è®¤è¯æµ‹è¯•å·²å¯åŠ¨ï¼Œè¯·æŸ¥çœ‹æµ‹è¯•ç»“æœ...', 'info');
        }
        
        // å¸®åŠ©å‡½æ•°ï¼šArrayBufferè½¬Base64
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }
        
        
        
        // ä½¿ç”¨libopusåˆ›å»ºä¸€ä¸ªOpusç¼–ç å™¨
        let opusEncoder = null;
        function initOpusEncoder() {
            try {
                if (opusEncoder) {
                    return true; // å·²ç»åˆå§‹åŒ–è¿‡
                }
                
                if (!window.ModuleInstance) {
                    log('æ— æ³•åˆ›å»ºOpusç¼–ç å™¨ï¼šModuleInstanceä¸å¯ç”¨', 'error');
                    return false;
                }
                
                // åˆå§‹åŒ–ä¸€ä¸ªOpusç¼–ç å™¨
                const mod = window.ModuleInstance;
                const sampleRate = 16000; // 16kHzé‡‡æ ·ç‡
                const channels = 1;       // å•å£°é“
                const application = 2048; // OPUS_APPLICATION_VOIP = 2048
                
                // åˆ›å»ºç¼–ç å™¨
                opusEncoder = {
                    channels: channels,
                    sampleRate: sampleRate,
                    frameSize: 960, // 60ms @ 16kHz = 60 * 16 = 960 samples
                    maxPacketSize: 4000, // æœ€å¤§åŒ…å¤§å°
                    module: mod,
                    
                    // åˆå§‹åŒ–ç¼–ç å™¨
                    init: function() {
                        try {
                            // è·å–ç¼–ç å™¨å¤§å°
                            const encoderSize = mod._opus_encoder_get_size(this.channels);
                            log(`Opusç¼–ç å™¨å¤§å°: ${encoderSize}å­—èŠ‚`, 'info');
                            
                            // åˆ†é…å†…å­˜
                            this.encoderPtr = mod._malloc(encoderSize);
                            if (!this.encoderPtr) {
                                throw new Error("æ— æ³•åˆ†é…ç¼–ç å™¨å†…å­˜");
                            }
                            
                            // åˆå§‹åŒ–ç¼–ç å™¨
                            const err = mod._opus_encoder_init(
                                this.encoderPtr,
                                this.sampleRate,
                                this.channels,
                                application
                            );
                            
                            if (err < 0) {
                                throw new Error(`Opusç¼–ç å™¨åˆå§‹åŒ–å¤±è´¥: ${err}`);
                            }
                            
                            // è®¾ç½®ä½ç‡ (16kbps)
                            mod._opus_encoder_ctl(this.encoderPtr, 4002, 16000); // OPUS_SET_BITRATE
                            
                            // è®¾ç½®å¤æ‚åº¦ (0-10, è¶Šé«˜è´¨é‡è¶Šå¥½ä½†CPUä½¿ç”¨è¶Šå¤š)
                            mod._opus_encoder_ctl(this.encoderPtr, 4010, 5);     // OPUS_SET_COMPLEXITY
                            
                            // è®¾ç½®ä½¿ç”¨DTX (ä¸ä¼ è¾“é™éŸ³å¸§)
                            mod._opus_encoder_ctl(this.encoderPtr, 4016, 1);     // OPUS_SET_DTX
                            
                            log("Opusç¼–ç å™¨åˆå§‹åŒ–æˆåŠŸ", 'success');
                            return true;
                        } catch (error) {
                            if (this.encoderPtr) {
                                mod._free(this.encoderPtr);
                                this.encoderPtr = null;
                            }
                            log(`Opusç¼–ç å™¨åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                            return false;
                        }
                    },
                    
                    // ç¼–ç PCMæ•°æ®ä¸ºOpus
                    encode: function(pcmData) {
                        if (!this.encoderPtr) {
                            if (!this.init()) {
                                return null;
                            }
                        }
                        
                        try {
                            const mod = this.module;
                            
                            // ä¸ºPCMæ•°æ®åˆ†é…å†…å­˜
                            const pcmPtr = mod._malloc(pcmData.length * 2); // 2å­—èŠ‚/int16
                            
                            // å°†PCMæ•°æ®å¤åˆ¶åˆ°HEAP
                            for (let i = 0; i < pcmData.length; i++) {
                                mod.HEAP16[(pcmPtr >> 1) + i] = pcmData[i];
                            }
                            
                            // ä¸ºè¾“å‡ºåˆ†é…å†…å­˜
                            const outPtr = mod._malloc(this.maxPacketSize);
                            
                            // è¿›è¡Œç¼–ç 
                            const encodedLen = mod._opus_encode(
                                this.encoderPtr,
                                pcmPtr,
                                this.frameSize,
                                outPtr,
                                this.maxPacketSize
                            );
                            
                            if (encodedLen < 0) {
                                throw new Error(`Opusç¼–ç å¤±è´¥: ${encodedLen}`);
                            }
                            
                            // å¤åˆ¶ç¼–ç åçš„æ•°æ®
                            const opusData = new Uint8Array(encodedLen);
                            for (let i = 0; i < encodedLen; i++) {
                                opusData[i] = mod.HEAPU8[outPtr + i];
                            }
                            
                            // é‡Šæ”¾å†…å­˜
                            mod._free(pcmPtr);
                            mod._free(outPtr);
                            
                            return opusData;
                        } catch (error) {
                            log(`Opusç¼–ç å‡ºé”™: ${error.message}`, 'error');
                            return null;
                        }
                    },
                    
                    // é”€æ¯ç¼–ç å™¨
                    destroy: function() {
                        if (this.encoderPtr) {
                            this.module._free(this.encoderPtr);
                            this.encoderPtr = null;
                        }
                    }
                };
                
                const result = opusEncoder.init();
                return result;
            } catch (error) {
                log(`åˆ›å»ºOpusç¼–ç å™¨å¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }
        
        // åˆå§‹åŒ–åº”ç”¨
        function initApp() {
            initVisualizer();
            initEventListeners();
            
            // æ£€æŸ¥libopus.jsæ˜¯å¦æ­£ç¡®åŠ è½½
            checkOpusLoaded();
            
            // åˆå§‹åŒ–Opusç¼–ç å™¨
            initOpusEncoder();
        }
        
        // PCMå½•éŸ³å¤„ç†å™¨ä»£ç  - ä¼šè¢«æ³¨å…¥åˆ°AudioWorkletä¸­
        const audioProcessorCode = `
            class AudioRecorderProcessor extends AudioWorkletProcessor {
                constructor() {
                    super();
                    this.buffers = [];
                    this.frameSize = 960; // 60ms @ 16kHz = 960 samples
                    this.buffer = new Int16Array(this.frameSize);
                    this.bufferIndex = 0;
                    this.isRecording = false;
                    
                    // ç›‘å¬æ¥è‡ªä¸»çº¿ç¨‹çš„æ¶ˆæ¯
                    this.port.onmessage = (event) => {
                        if (event.data.command === 'start') {
                            this.isRecording = true;
                            this.port.postMessage({ type: 'status', status: 'started' });
                        } else if (event.data.command === 'stop') {
                            this.isRecording = false;
                            
                            // å‘é€å‰©ä½™çš„ç¼“å†²åŒº
                            if (this.bufferIndex > 0) {
                                const finalBuffer = this.buffer.slice(0, this.bufferIndex);
                                this.port.postMessage({
                                    type: 'buffer',
                                    buffer: finalBuffer
                                });
                                this.bufferIndex = 0;
                            }
                            
                            this.port.postMessage({ type: 'status', status: 'stopped' });
                        }
                    };
                }
                
                process(inputs, outputs, parameters) {
                    if (!this.isRecording) return true;
                    
                    const input = inputs[0][0]; // è·å–ç¬¬ä¸€ä¸ªè¾“å…¥é€šé“
                    if (!input) return true;
                    
                    // å°†æµ®ç‚¹é‡‡æ ·è½¬æ¢ä¸º16ä½æ•´æ•°å¹¶å­˜å‚¨
                    for (let i = 0; i < input.length; i++) {
                        if (this.bufferIndex >= this.frameSize) {
                            // ç¼“å†²åŒºå·²æ»¡ï¼Œå‘é€ç»™ä¸»çº¿ç¨‹å¹¶é‡ç½®
                            this.port.postMessage({
                                type: 'buffer',
                                buffer: this.buffer.slice(0)
                            });
                            this.bufferIndex = 0;
                        }
                        
                        // è½¬æ¢ä¸º16ä½æ•´æ•° (-32768åˆ°32767)
                        this.buffer[this.bufferIndex++] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                    }
                    
                    return true;
                }
            }
            
            registerProcessor('audio-recorder-processor', AudioRecorderProcessor);
        `;
        
        // åˆ›å»ºéŸ³é¢‘å¤„ç†å™¨
        async function createAudioProcessor() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,
                    latencyHint: 'interactive'
                });
            }
            
            try {
                // æ£€æŸ¥æ˜¯å¦æ”¯æŒAudioWorklet
                if (audioContext.audioWorklet) {
                    // æ³¨å†ŒéŸ³é¢‘å¤„ç†å™¨
                    const blob = new Blob([audioProcessorCode], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    await audioContext.audioWorklet.addModule(url);
                    URL.revokeObjectURL(url);
                    
                    // åˆ›å»ºéŸ³é¢‘å¤„ç†èŠ‚ç‚¹
                    const audioProcessor = new AudioWorkletNode(audioContext, 'audio-recorder-processor');
                    
                    // è®¾ç½®éŸ³é¢‘å¤„ç†æ¶ˆæ¯å¤„ç†
                    audioProcessor.port.onmessage = (event) => {
                        if (event.data.type === 'buffer') {
                            // æ”¶åˆ°PCMç¼“å†²åŒºæ•°æ®
                            processPCMBuffer(event.data.buffer);
                        }
                    };
                    
                    log('ä½¿ç”¨AudioWorkletå¤„ç†éŸ³é¢‘', 'success');
                    return { node: audioProcessor, type: 'worklet' };
                } else {
                    // ä½¿ç”¨æ—§ç‰ˆScriptProcessorNodeä½œä¸ºå›é€€æ–¹æ¡ˆ
                    log('AudioWorkletä¸å¯ç”¨ï¼Œä½¿ç”¨ScriptProcessorNodeä½œä¸ºå›é€€æ–¹æ¡ˆ', 'warning');
                    
                    const frameSize = 4096; // ScriptProcessorNodeç¼“å†²åŒºå¤§å°
                    const scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);
                    
                    // å°†audioProcessäº‹ä»¶è®¾ç½®ä¸ºå¤„ç†éŸ³é¢‘æ•°æ®
                    scriptProcessor.onaudioprocess = (event) => {
                        if (!isRecording) return;
                        
                        const input = event.inputBuffer.getChannelData(0);
                        const buffer = new Int16Array(input.length);
                        
                        // å°†æµ®ç‚¹æ•°æ®è½¬æ¢ä¸º16ä½æ•´æ•°
                        for (let i = 0; i < input.length; i++) {
                            buffer[i] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                        }
                        
                        // å¤„ç†PCMæ•°æ®
                        processPCMBuffer(buffer);
                    };
                    
                    // éœ€è¦è¿æ¥è¾“å‡ºï¼Œå¦åˆ™ä¸ä¼šè§¦å‘å¤„ç†
                    // æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªé™éŸ³é€šé“
                    const silent = audioContext.createGain();
                    silent.gain.value = 0;
                    scriptProcessor.connect(silent);
                    silent.connect(audioContext.destination);
                    
                    return { node: scriptProcessor, type: 'processor' };
                }
            } catch (error) {
                log(`åˆ›å»ºéŸ³é¢‘å¤„ç†å™¨å¤±è´¥: ${error.message}ï¼Œå°è¯•å›é€€æ–¹æ¡ˆ`, 'error');
                
                // æœ€åå›é€€æ–¹æ¡ˆï¼šä½¿ç”¨ScriptProcessorNode
                try {
                    const frameSize = 4096; // ScriptProcessorNodeç¼“å†²åŒºå¤§å°
                    const scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);
                    
                    scriptProcessor.onaudioprocess = (event) => {
                        if (!isRecording) return;
                        
                        const input = event.inputBuffer.getChannelData(0);
                        const buffer = new Int16Array(input.length);
                        
                        for (let i = 0; i < input.length; i++) {
                            buffer[i] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                        }
                        
                        processPCMBuffer(buffer);
                    };
                    
                    const silent = audioContext.createGain();
                    silent.gain.value = 0;
                    scriptProcessor.connect(silent);
                    silent.connect(audioContext.destination);
                    
                    log('ä½¿ç”¨ScriptProcessorNodeä½œä¸ºå›é€€æ–¹æ¡ˆæˆåŠŸ', 'warning');
                    return { node: scriptProcessor, type: 'processor' };
                } catch (fallbackError) {
                    log(`å›é€€æ–¹æ¡ˆä¹Ÿå¤±è´¥: ${fallbackError.message}`, 'error');
                    return null;
                }
            }
        }
        
        // åˆå§‹åŒ–ç›´æ¥ä»PCMæ•°æ®å½•éŸ³çš„ç³»ç»Ÿ
        let audioProcessor = null;
        let audioProcessorType = null;
        let audioSource = null;
        let pcmBuffers = [];
        
        // å¤„ç†PCMç¼“å†²æ•°æ®
        let pcmDataBuffer = new Int16Array();
        function processPCMBuffer(buffer) {
            if (!isRecording) return;
            
            // å°†æ–°çš„PCMæ•°æ®è¿½åŠ åˆ°ç¼“å†²åŒº
            const newBuffer = new Int16Array(pcmDataBuffer.length + buffer.length);
            newBuffer.set(pcmDataBuffer);
            newBuffer.set(buffer, pcmDataBuffer.length);
            pcmDataBuffer = newBuffer;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ•°æ®è¿›è¡ŒOpusç¼–ç ï¼ˆ16000Hz, 60ms = 960ä¸ªé‡‡æ ·ç‚¹ï¼‰
            const samplesPerFrame = 960; // 60ms @ 16kHz
            
            while (pcmDataBuffer.length >= samplesPerFrame) {
                // ä»ç¼“å†²åŒºå–å‡ºä¸€å¸§æ•°æ®
                const frameData = pcmDataBuffer.slice(0, samplesPerFrame);
                pcmDataBuffer = pcmDataBuffer.slice(samplesPerFrame);
                
                // ç¼–ç ä¸ºOpus
                encodeAndSendOpus(frameData);
            }
        }
        
        // ç¼–ç å¹¶å‘é€Opusæ•°æ®
        function encodeAndSendOpus(pcmData = null) {
            if (!opusEncoder) {
                log('Opusç¼–ç å™¨æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            try {
                // å¦‚æœæä¾›äº†PCMæ•°æ®ï¼Œåˆ™ç¼–ç è¯¥æ•°æ®
                if (pcmData) {
                    // ä½¿ç”¨å·²åˆå§‹åŒ–çš„Opusç¼–ç å™¨ç¼–ç 
                    const opusData = opusEncoder.encode(pcmData);
                    
                    if (opusData && opusData.length > 0) {
                        // å­˜å‚¨éŸ³é¢‘å¸§
                        audioBuffers.push(opusData.buffer);
                        totalAudioSize += opusData.length;
                        
                        // å¦‚æœWebSocketå·²è¿æ¥ï¼Œåˆ™å‘é€æ•°æ®
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            try {
                                // æœåŠ¡ç«¯æœŸæœ›æ¥æ”¶åŸå§‹Opusæ•°æ®ï¼Œä¸éœ€è¦ä»»ä½•é¢å¤–åŒ…è£…
                                websocket.send(opusData.buffer);
                                log(`å‘é€Opuså¸§ï¼Œå¤§å°ï¼š${opusData.length}å­—èŠ‚`, 'debug');
                            } catch (error) {
                                log(`WebSocketå‘é€é”™è¯¯: ${error.message}`, 'error');
                            }
                        }
                    } else {
                        log('Opusç¼–ç å¤±è´¥ï¼Œæ— æœ‰æ•ˆæ•°æ®è¿”å›', 'error');
                    }
                } else {
                    // å¤„ç†å‰©ä½™çš„PCMæ•°æ®
                    if (pcmDataBuffer.length > 0) {
                        // å¦‚æœå‰©ä½™çš„é‡‡æ ·ç‚¹ä¸è¶³ä¸€å¸§ï¼Œç”¨é™éŸ³å¡«å……
                        const samplesPerFrame = 960;
                        if (pcmDataBuffer.length < samplesPerFrame) {
                            const paddedBuffer = new Int16Array(samplesPerFrame);
                            paddedBuffer.set(pcmDataBuffer);
                            // å‰©ä½™éƒ¨åˆ†ä¸º0ï¼ˆé™éŸ³ï¼‰
                            encodeAndSendOpus(paddedBuffer);
                        } else {
                            encodeAndSendOpus(pcmDataBuffer.slice(0, samplesPerFrame));
                        }
                        pcmDataBuffer = new Int16Array(0);
                    }
                }
            } catch (error) {
                log(`Opusç¼–ç é”™è¯¯: ${error.message}`, 'error');
            }
        }
        
        // å¼€å§‹ç›´æ¥ä»PCMæ•°æ®å½•éŸ³
        async function startDirectRecording() {
            if (isRecording) return;
            
            try {
                // åˆå§‹åŒ–Opusç¼–ç å™¨
                if (!initOpusEncoder()) {
                    log('æ— æ³•å¯åŠ¨å½•éŸ³: Opusç¼–ç å™¨åˆå§‹åŒ–å¤±è´¥', 'error');
                    return;
                }
                
                // è¯·æ±‚éº¦å…‹é£æƒé™
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000,
                        channelCount: 1
                    }
                });
                
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡å’Œåˆ†æå™¨
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000,
                        latencyHint: 'interactive'
                    });
                }
                
                // åˆ›å»ºéŸ³é¢‘å¤„ç†å™¨
                const processorResult = await createAudioProcessor();
                if (!processorResult) {
                    log('æ— æ³•åˆ›å»ºéŸ³é¢‘å¤„ç†å™¨', 'error');
                    return;
                }
                
                audioProcessor = processorResult.node;
                audioProcessorType = processorResult.type;
                
                // è¿æ¥éŸ³é¢‘å¤„ç†é“¾
                audioSource = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                audioSource.connect(analyser);
                audioSource.connect(audioProcessor);
                
                // å¯åŠ¨å½•éŸ³
                pcmDataBuffer = new Int16Array();
                audioBuffers = [];
                totalAudioSize = 0;
                isRecording = true;
                
                // å¯åŠ¨éŸ³é¢‘å¤„ç†å™¨çš„å½•éŸ³ - åªæœ‰AudioWorkletæ‰éœ€è¦å‘é€æ¶ˆæ¯
                if (audioProcessorType === 'worklet' && audioProcessor.port) {
                    audioProcessor.port.postMessage({ command: 'start' });
                }
                
                // å‘é€ç›‘å¬å¼€å§‹æ¶ˆæ¯
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    // ä½¿ç”¨ä¸æœåŠ¡ç«¯æœŸæœ›çš„listenæ¶ˆæ¯æ ¼å¼
                    const listenMessage = {
                        type: 'listen',
                        mode: 'manual',  // ä½¿ç”¨æ‰‹åŠ¨æ¨¡å¼ï¼Œç”±æˆ‘ä»¬æ§åˆ¶å¼€å§‹/åœæ­¢
                        state: 'start'   // è¡¨ç¤ºå¼€å§‹å½•éŸ³
                    };
                    
                    log(`å‘é€å½•éŸ³å¼€å§‹æ¶ˆæ¯: ${JSON.stringify(listenMessage)}`, 'info');
                    websocket.send(JSON.stringify(listenMessage));
                } else {
                    log('WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€å¼€å§‹æ¶ˆæ¯', 'error');
                    return false;
                }
                
                // å¼€å§‹éŸ³é¢‘å¯è§†åŒ–
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                drawVisualizer(dataArray);
                
                // åœ¨UIä¸Šæ˜¾ç¤ºå½•éŸ³è®¡æ—¶å™¨
                let recordingSeconds = 0;
                const recordingTimer = setInterval(() => {
                    recordingSeconds += 0.1;
                    recordButton.textContent = `å½•éŸ³ä¸­... ${recordingSeconds.toFixed(1)}ç§’`;
                }, 100);
                
                // ä¿å­˜è®¡æ—¶å™¨ï¼Œä»¥ä¾¿åœ¨åœæ­¢æ—¶æ¸…é™¤
                window.recordingTimer = recordingTimer;
                
                recordButton.classList.add('recording');
                recordButton.disabled = true;
                stopButton.disabled = false;
                
                log('å¼€å§‹PCMç›´æ¥å½•éŸ³', 'success');
                return true;
            } catch (error) {
                log(`ç›´æ¥å½•éŸ³å¯åŠ¨é”™è¯¯: ${error.message}`, 'error');
                isRecording = false;
                return false;
            }
        }
        
        // åœæ­¢ç›´æ¥ä»PCMæ•°æ®å½•éŸ³
        function stopDirectRecording() {
            if (!isRecording) return;
            
            try {
                // åœæ­¢å½•éŸ³
                isRecording = false;
                
                // åœæ­¢éŸ³é¢‘å¤„ç†å™¨çš„å½•éŸ³
                if (audioProcessor) {
                    // åªæœ‰AudioWorkletæ‰éœ€è¦å‘é€åœæ­¢æ¶ˆæ¯
                    if (audioProcessorType === 'worklet' && audioProcessor.port) {
                        audioProcessor.port.postMessage({ command: 'stop' });
                    }
                    
                    audioProcessor.disconnect();
                    audioProcessor = null;
                }
                
                // æ–­å¼€éŸ³é¢‘è¿æ¥
                if (audioSource) {
                    audioSource.disconnect();
                    audioSource = null;
                }
                
                // åœæ­¢å¯è§†åŒ–
                if (visualizationRequest) {
                    cancelAnimationFrame(visualizationRequest);
                    visualizationRequest = null;
                }
                
                // æ¸…é™¤å½•éŸ³è®¡æ—¶å™¨
                if (window.recordingTimer) {
                    clearInterval(window.recordingTimer);
                    window.recordingTimer = null;
                }
                
                // ç¼–ç å¹¶å‘é€å‰©ä½™çš„æ•°æ®
                encodeAndSendOpus();
                
                // å‘é€ä¸€ä¸ªç©ºçš„æ¶ˆæ¯ä½œä¸ºç»“æŸæ ‡å¿—ï¼ˆæ¨¡æ‹Ÿæ¥æ”¶åˆ°ç©ºéŸ³é¢‘æ•°æ®çš„æƒ…å†µï¼‰
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    // ä½¿ç”¨ç©ºçš„Uint8Arrayå‘é€æœ€åä¸€ä¸ªç©ºå¸§
                    const emptyOpusFrame = new Uint8Array(0);
                    websocket.send(emptyOpusFrame);
                    
                    // å‘é€ç›‘å¬ç»“æŸæ¶ˆæ¯
                    const stopMessage = {
                        type: 'listen',
                        mode: 'manual',
                        state: 'stop'
                    };
                    
                    websocket.send(JSON.stringify(stopMessage));
                    log('å·²å‘é€å½•éŸ³åœæ­¢ä¿¡å·', 'info');
                }
                
                // é‡ç½®UI
                recordButton.textContent = 'å¼€å§‹å½•éŸ³';
                recordButton.classList.remove('recording');
                recordButton.disabled = false;
                stopButton.disabled = true;
                
                log('åœæ­¢PCMç›´æ¥å½•éŸ³', 'success');
                return true;
            } catch (error) {
                log(`ç›´æ¥å½•éŸ³åœæ­¢é”™è¯¯: ${error.message}`, 'error');
                return false;
            }
        }
        
        // å¤„ç†äºŒè¿›åˆ¶æ¶ˆæ¯
        async function handleBinaryMessage(data) {
            try {
                let arrayBuffer;
                
                // æ ¹æ®æ•°æ®ç±»å‹è¿›è¡Œå¤„ç†
                if (data instanceof ArrayBuffer) {
                    arrayBuffer = data;
                    log(`æ”¶åˆ°ArrayBufferéŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${data.byteLength}å­—èŠ‚`, 'debug');
                } else if (data instanceof Blob) {
                    // å¦‚æœæ˜¯Blobç±»å‹ï¼Œè½¬æ¢ä¸ºArrayBuffer
                    arrayBuffer = await data.arrayBuffer();
                    log(`æ”¶åˆ°BlobéŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${arrayBuffer.byteLength}å­—èŠ‚`, 'debug');
                } else {
                    log(`æ”¶åˆ°æœªçŸ¥ç±»å‹çš„äºŒè¿›åˆ¶æ•°æ®: ${typeof data}`, 'warning');
                    return;
                }
                
                // åˆ›å»ºUint8Arrayç”¨äºå¤„ç†
                const opusData = new Uint8Array(arrayBuffer);
                
                if (opusData.length > 0) {
                    // æ’­æ”¾OpuséŸ³é¢‘
                    playOpusData([opusData]);
                } else {
                    log('æ”¶åˆ°ç©ºéŸ³é¢‘æ•°æ®å¸§', 'warning');
                }
            } catch (error) {
                log(`å¤„ç†äºŒè¿›åˆ¶æ¶ˆæ¯å‡ºé”™: ${error.message}`, 'error');
            }
        }
        
        initApp();
    </script>
</body>
</html> 