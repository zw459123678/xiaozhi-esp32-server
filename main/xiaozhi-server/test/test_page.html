<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â∞èÊô∫ÊúçÂä°Âô®ÊµãËØïÈ°µÈù¢</title>
    <style>
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 10px 20px 10px 20px;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        .section h2 {
            margin-top: 0;
            color: #444;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background-color: #4285f4;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #3367d6;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #serverUrl {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .message-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #messageInput {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        #nfcCardId {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .conversation {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: white;
            flex: 1;
            margin-right: 10px;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 80%;
        }

        .user {
            background-color: #e2f2ff;
            margin-left: auto;
            margin-right: 10px;
            text-align: right;
        }

        .server {
            background-color: #f0f0f0;
            margin-right: auto;
            margin-left: 10px;
        }

        .status {
            color: #666;
            font-style: italic;
            font-size: 14px;
            margin: 0;
            padding: 0;
        }

        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .audio-visualizer {
            height: 60px;
            width: 100%;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }

        .record-button {
            background-color: #db4437;
        }

        .record-button:hover {
            background-color: #c53929;
        }

        .record-button.recording {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                background-color: #db4437;
            }

            50% {
                background-color: #ff6659;
            }

            100% {
                background-color: #db4437;
            }
        }

        #logContainer {
            margin-top: 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            font-family: monospace;
            height: 300px;
            overflow-y: auto;
            flex: 1;
            margin-left: 10px;
        }

        .log-entry {
            margin: 5px 0;
            font-size: 12px;
        }

        .log-info {
            color: #333;
        }

        .log-error {
            color: #db4437;
        }

        .log-success {
            color: #0f9d58;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .script-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .script-loaded {
            background-color: #0f9d58;
        }

        .script-loading {
            background-color: #f4b400;
        }

        .script-error {
            background-color: #db4437;
        }

        .script-list {
            margin: 10px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }

        #scriptStatus.success {
            background-color: #e6f4ea;
            color: #0f9d58;
            border-left: 4px solid #0f9d58;
        }

        #scriptStatus.error {
            background-color: #fce8e6;
            color: #db4437;
            border-left: 4px solid #db4437;
        }

        #scriptStatus.warning {
            background-color: #fef7e0;
            color: #f4b400;
            border-left: 4px solid #f4b400;
        }

        /* Ê†áÁ≠æÈ°µÊ†∑Âºè */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            color: #666;
            position: relative;
            transition: all 0.3s ease;
        }

        .tab:hover {
            color: #4285f4;
        }

        .tab.active {
            color: #4285f4;
            font-weight: bold;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #4285f4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .flex-container {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Â∞èÊô∫ÊúçÂä°Âô®ÊµãËØïÈ°µÈù¢</h1>

        <div id="scriptStatus" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);">
            Ê≠£Âú®Âä†ËΩΩOpusÂ∫ì...</div>

        <div class="section">
            <h2>WebSocketËøûÊé• <span id="connectionStatus" class="status">Êú™ËøûÊé•</span></h2>
            <div class="control-panel">
                <input type="text" id="serverUrl" value="ws://127.0.0.1:8000/xiaozhi/v1/" placeholder="WebSocketÊúçÂä°Âô®Âú∞ÂùÄ">
                <button id="connectButton">ËøûÊé•</button>
                <button id="authTestButton">ÊµãËØïËÆ§ËØÅ</button>
            </div>
        </div>

        <div class="section">
            <h2>Ê∂àÊÅØÂèëÈÄÅ</h2>
            <div class="tabs">
                <button class="tab active" data-tab="text">ÊñáÊú¨Ê∂àÊÅØ</button>
                <button class="tab" data-tab="voice">ËØ≠Èü≥Ê∂àÊÅØ</button>
            </div>

            <div class="tab-content active" id="textTab">
                <div class="message-input">
                    <input type="text" id="messageInput" placeholder="ËæìÂÖ•Ê∂àÊÅØ..." disabled>
                    <button id="sendTextButton" disabled>ÂèëÈÄÅ</button>
                </div>
            </div>

            <div class="tab-content" id="voiceTab">
                <div class="audio-controls">
                    <button id="recordButton" class="record-button" disabled>ÂºÄÂßãÂΩïÈü≥</button>
                </div>
                <canvas id="audioVisualizer" class="audio-visualizer"></canvas>
            </div>
        </div>

        <div class="section">
            <h2>‰ºöËØùËÆ∞ÂΩï</h2>
            <div class="flex-container">
                <div id="conversation" class="conversation"></div>
                <div id="logContainer">
                    <div class="log-entry log-info">ÂáÜÂ§áÂ∞±Áª™ÔºåËØ∑ËøûÊé•ÊúçÂä°Âô®ÂºÄÂßãÊµãËØï...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- OpusËß£Á†ÅÂ∫ì -->
    <script src="libopus.js"></script>

    <script>
        // ÈúÄË¶ÅÂä†ËΩΩÁöÑËÑöÊú¨ÂàóË°® - ÁßªÈô§Opus‰æùËµñ
        const scriptFiles = [];

        // ËÑöÊú¨Âä†ËΩΩÁä∂ÊÄÅ
        const scriptStatus = {
            loading: 0,
            loaded: 0,
            failed: 0,
            total: scriptFiles.length
        };

        // Ê£ÄÊü•OpusÂ∫ìÊòØÂê¶Â∑≤Âä†ËΩΩ
        function checkOpusLoaded() {
            try {
                // Ê£ÄÊü•ModuleÊòØÂê¶Â≠òÂú®ÔºàÊú¨Âú∞Â∫ìÂØºÂá∫ÁöÑÂÖ®Â±ÄÂèòÈáèÔºâ
                if (typeof Module === 'undefined') {
                    throw new Error('OpusÂ∫ìÊú™Âä†ËΩΩÔºåModuleÂØπË±°‰∏çÂ≠òÂú®');
                }

                // Â∞ùËØïÂÖà‰ΩøÁî®Module.instanceÔºàlibopus.jsÊúÄÂêé‰∏ÄË°åÂØºÂá∫ÊñπÂºèÔºâ
                if (typeof Module.instance !== 'undefined' && typeof Module.instance._opus_decoder_get_size === 'function') {
                    // ‰ΩøÁî®Module.instanceÂØπË±°ÊõøÊç¢ÂÖ®Â±ÄModuleÂØπË±°
                    window.ModuleInstance = Module.instance;
                    log('OpusÂ∫ìÂä†ËΩΩÊàêÂäüÔºà‰ΩøÁî®Module.instanceÔºâ', 'success');
                    updateScriptStatus('OpusÂ∫ìÂä†ËΩΩÊàêÂäü', 'success');

                    // 3ÁßíÂêéÈöêËóèÁä∂ÊÄÅ
                    const statusElement = document.getElementById('scriptStatus');
                    if (statusElement) statusElement.style.display = 'none';
                    return;
                }

                // Â¶ÇÊûúÊ≤°ÊúâModule.instanceÔºåÊ£ÄÊü•ÂÖ®Â±ÄModuleÂáΩÊï∞
                if (typeof Module._opus_decoder_get_size === 'function') {
                    window.ModuleInstance = Module;
                    log('OpusÂ∫ìÂä†ËΩΩÊàêÂäüÔºà‰ΩøÁî®ÂÖ®Â±ÄModuleÔºâ', 'success');
                    updateScriptStatus('OpusÂ∫ìÂä†ËΩΩÊàêÂäü', 'success');

                    // 3ÁßíÂêéÈöêËóèÁä∂ÊÄÅ
                    const statusElement = document.getElementById('scriptStatus');
                    if (statusElement) statusElement.style.display = 'none';
                    return;
                }

                throw new Error('OpusËß£Á†ÅÂáΩÊï∞Êú™ÊâæÂà∞ÔºåÂèØËÉΩModuleÁªìÊûÑ‰∏çÊ≠£Á°Æ');
            } catch (err) {
                log(`OpusÂ∫ìÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•libopus.jsÊñá‰ª∂ÊòØÂê¶Â≠òÂú®‰∏îÊ≠£Á°Æ: ${err.message}`, 'error');
                updateScriptStatus('OpusÂ∫ìÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•libopus.jsÊñá‰ª∂ÊòØÂê¶Â≠òÂú®‰∏îÊ≠£Á°Æ', 'error');
            }
        }

        // Êõ¥Êñ∞ËÑöÊú¨Áä∂ÊÄÅÊòæÁ§∫
        function updateScriptStatus(message, type) {
            const statusElement = document.getElementById('scriptStatus');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `script-status ${type}`;
                statusElement.style.display = 'block';
                statusElement.style.width = 'auto';
            }
        }

        // ÂÖ®Â±ÄÂèòÈáè
        let websocket = null;
        let mediaRecorder = null;
        let audioContext = null;
        let analyser = null;
        let audioChunks = [];
        let isRecording = false;
        let visualizerCanvas = document.getElementById('audioVisualizer');
        let visualizerContext = visualizerCanvas.getContext('2d');
        let audioQueue = [];
        let isPlaying = false;
        let opusDecoder = null; // OpusËß£Á†ÅÂô®
        let visualizationRequest = null; // Âä®ÁîªÂ∏ßËØ∑Ê±ÇID

        // Èü≥È¢ëÊµÅÁºìÂÜ≤Áõ∏ÂÖ≥
        let audioBuffers = []; // Áî®‰∫éÂ≠òÂÇ®Êé•Êî∂Âà∞ÁöÑÊâÄÊúâÈü≥È¢ëÊï∞ÊçÆ
        let totalAudioSize = 0; // Ë∑üË∏™Á¥ØÁßØÁöÑÈü≥È¢ëÂ§ßÂ∞è

        // DOMÂÖÉÁ¥†
        const connectButton = document.getElementById('connectButton');
        const serverUrlInput = document.getElementById('serverUrl');
        const connectionStatus = document.getElementById('connectionStatus');
        const messageInput = document.getElementById('messageInput');
        const sendTextButton = document.getElementById('sendTextButton');
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const conversationDiv = document.getElementById('conversation');
        const logContainer = document.getElementById('logContainer');

        // Êó•ÂøóÂáΩÊï∞
        function log(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (type === 'error') {
                logEntry.style.color = 'red';
            } else if (type === 'debug') {
                logEntry.style.color = 'gray';
                return;
            } else if (type === 'warning') {
                logEntry.style.color = 'orange';
            } else if (type === 'success') {
                logEntry.style.color = 'green';
            } else {
                logEntry.style.color = 'black';
            }
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // ÂàùÂßãÂåñÂèØËßÜÂåñÂô®
        function initVisualizer() {
            visualizerCanvas.width = visualizerCanvas.clientWidth;
            visualizerCanvas.height = visualizerCanvas.clientHeight;
            visualizerContext.fillStyle = '#fafafa';
            visualizerContext.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
        }

        // ÁªòÂà∂Èü≥È¢ëÂèØËßÜÂåñÊïàÊûú
        function drawVisualizer(dataArray) {
            visualizationRequest = requestAnimationFrame(() => drawVisualizer(dataArray));

            if (!isRecording) return;

            analyser.getByteFrequencyData(dataArray);

            visualizerContext.fillStyle = '#fafafa';
            visualizerContext.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

            const barWidth = (visualizerCanvas.width / dataArray.length) * 2.5;
            let barHeight;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                barHeight = dataArray[i] / 2;

                visualizerContext.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                visualizerContext.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);

                x += barWidth + 1;
            }
        }

        // Ê∑ªÂä†Ê∂àÊÅØÂà∞‰ºöËØùËÆ∞ÂΩï
        function addMessage(text, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'server'}`;
            messageDiv.textContent = text;
            conversationDiv.appendChild(messageDiv);
            conversationDiv.scrollTop = conversationDiv.scrollHeight;
        }

        // Êí≠ÊîæOpusÈü≥È¢ëÊï∞ÊçÆ
        function playOpusData(opusBuffers) {
            if (!opusBuffers || opusBuffers.length === 0) {
                log('Êó†ÊïàÁöÑOpusÊï∞ÊçÆÔºåÊó†Ê≥ïÊí≠Êîæ', 'warning');
                return;
            }

            if (isPlaying) {
                // Â∑≤ÁªèÂú®Êí≠ÊîæÔºåÂä†ÂÖ•ÈòüÂàó
                audioQueue.push(opusBuffers);
                log(`Èü≥È¢ëÊ∑ªÂä†Âà∞ÈòüÂàóÔºåÂΩìÂâçÈòüÂàóÈïøÂ∫¶: ${audioQueue.length}`, 'debug');
                return;
            }

            isPlaying = true;

            try {
                // Á°Æ‰øùÈü≥È¢ë‰∏ä‰∏ãÊñáÂ≠òÂú®
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });
                    log('ÂàõÂª∫Èü≥È¢ë‰∏ä‰∏ãÊñáÔºåÈááÊ†∑Áéá: 16000Hz', 'debug');
                }

                // Á°Æ‰øùËß£Á†ÅÂô®Â∑≤ÂàùÂßãÂåñ
                if (!opusDecoder) {
                    try {
                        // Ê£ÄÊü•ModuleInstanceÊòØÂê¶Â≠òÂú®ÔºàÊú¨Âú∞Â∫ìÂØºÂá∫ÁöÑÂÖ®Â±ÄÂèòÈáèÔºâ
                        if (typeof window.ModuleInstance === 'undefined') {
                            if (typeof Module !== 'undefined') {
                                // Â∞ùËØï‰ΩøÁî®ÂÖ®Â±ÄModule
                                window.ModuleInstance = Module;
                                log('‰ΩøÁî®ÂÖ®Â±ÄModule‰Ωú‰∏∫ModuleInstance', 'info');
                            } else {
                                throw new Error('OpusÂ∫ìÊú™Âä†ËΩΩÔºåModuleInstanceÂíåModuleÂØπË±°ÈÉΩ‰∏çÂ≠òÂú®');
                            }
                        }

                        // ÂàùÂßãÂåñOpusËß£Á†ÅÂô® - 16kHzÈááÊ†∑ÁéáÔºåÂçïÂ£∞ÈÅì
                        opusDecoder = {
                            channels: 1,
                            rate: 16000,
                            frameSize: 960, // 60ms @ 16kHz = 60 * 16 = 960 samples
                            frameDuration: 60, // 60msÂ∏ßÊó∂Èïø
                            module: window.ModuleInstance, // ‰øùÂ≠òÊ®°ÂùóÂÆû‰æãÁöÑÂºïÁî®

                            // ‰ΩøÁî®ModuleInstanceÊèê‰æõÁöÑÂáΩÊï∞Êù•Ëß£Á†Å
                            decode_float: function (opusData) {
                                try {
                                    const mod = this.module; // ÁÆÄÂÜôÂºïÁî®

                                    // ÊâìÂç∞ËæìÂÖ•Êï∞ÊçÆÁöÑÂ§ßÂ∞è
                                    log(`Ê≠£Âú®Ëß£Á†ÅOpusÊï∞ÊçÆÔºåÂ§ßÂ∞è: ${opusData.length}Â≠óËäÇ`, 'debug');

                                    // ‰∏∫ËæìÂÖ•Êï∞ÊçÆÂàÜÈÖçÂÜÖÂ≠ò
                                    const inputPtr = mod._malloc(opusData.length);
                                    mod.HEAPU8.set(opusData, inputPtr);

                                    // ‰∏∫ËæìÂá∫PCMÊï∞ÊçÆÂàÜÈÖçÂÜÖÂ≠ò (ÊØè‰∏™Ê†∑Êú¨‰∏∫float)
                                    const pcmSamples = this.frameSize;
                                    const pcmPtr = mod._malloc(pcmSamples * 4); // 4Â≠óËäÇ/float

                                    // ÂàõÂª∫Ëß£Á†ÅÂô®ÂÆû‰æã
                                    const decoderSize = mod._opus_decoder_get_size(this.channels);
                                    log(`OpusËß£Á†ÅÂô®Â§ßÂ∞è: ${decoderSize}Â≠óËäÇ`, 'debug');

                                    const decoderPtr = mod._malloc(decoderSize);
                                    const err = mod._opus_decoder_init(decoderPtr, this.rate, this.channels);

                                    if (err < 0) {
                                        throw new Error(`OpusËß£Á†ÅÂô®ÂàùÂßãÂåñÂ§±Ë¥•: ${err}`);
                                    }

                                    // Ëß£Á†ÅÈü≥È¢ëÂ∏ß
                                    const samplesDecoded = mod._opus_decode_float(
                                        decoderPtr,
                                        inputPtr,
                                        opusData.length,
                                        pcmPtr,
                                        this.frameSize,
                                        0 // ‰∏ç‰ΩøÁî®FEC
                                    );

                                    if (samplesDecoded < 0) {
                                        throw new Error(`OpusËß£Á†ÅÂ§±Ë¥•ÔºåÈîôËØØÁ†Å: ${samplesDecoded}`);
                                    }

                                    log(`Ëß£Á†ÅÊàêÂäüÔºåËé∑Âæó${samplesDecoded}‰∏™PCMÊ†∑Êú¨`, 'debug');

                                    // ‰ªéÂÜÖÂ≠ò‰∏≠Â§çÂà∂PCMÊï∞ÊçÆ
                                    const pcmData = new Float32Array(samplesDecoded);
                                    for (let i = 0; i < samplesDecoded; i++) {
                                        pcmData[i] = mod.HEAPF32[pcmPtr / 4 + i];
                                    }

                                    // ÈáäÊîæÂÜÖÂ≠ò
                                    mod._free(inputPtr);
                                    mod._free(pcmPtr);
                                    mod._free(decoderPtr);

                                    return pcmData;
                                } catch (err) {
                                    log(`Ëß£Á†ÅËøáÁ®ã‰∏≠Âá∫Èîô: ${err.message}`, 'error');
                                    return new Float32Array(0);
                                }
                            }
                        };

                        log('OpusËß£Á†ÅÂô®ÂàùÂßãÂåñÊàêÂäü', 'success');
                    } catch (err) {
                        log(`OpusËß£Á†ÅÂô®ÂàùÂßãÂåñÂ§±Ë¥•: ${err.message}ÔºåÂ∞ùËØï‰ΩøÁî®ÁÆÄÂçïÊí≠Êîæ`, 'error');
                        // ÂõûÈÄÄÂà∞ÁÆÄÂçïÊí≠Êîæ
                        simpleFallbackPlay(opusBuffers);
                        isPlaying = false;
                        return;
                    }
                }

                // Ëß£Á†ÅÊâÄÊúâOpusÂ∏ß
                let pcmData = [];
                let successCount = 0;

                for (let i = 0; i < opusBuffers.length; i++) {
                    try {
                        const opusBuffer = opusBuffers[i];
                        // Á°Æ‰øùËøôÊòØUint8Array
                        const opusArray = opusBuffer instanceof Uint8Array ?
                            opusBuffer : new Uint8Array(opusBuffer);

                        // Ëß£Á†ÅOpusÂ∏ß‰∏∫PCMÊï∞ÊçÆ
                        const decoded = opusDecoder.decode_float(opusArray);
                        if (decoded && decoded.length > 0) {
                            pcmData.push(decoded);
                            successCount++;
                        }
                    } catch (error) {
                        log(`OpusÂ∏ß #${i + 1} Ëß£Á†ÅÈîôËØØ: ${error.message}`, 'error');
                    }
                }

                log(`Ëß£Á†ÅÂÆåÊàêÔºåÊàêÂäü: ${successCount}/${opusBuffers.length} Â∏ß`, 'debug');

                if (pcmData.length === 0) {
                    log('Ê≤°ÊúâÊàêÂäüËß£Á†ÅÁöÑÂ∏ßÔºåÂ∞ùËØï‰ΩøÁî®ÁÆÄÂçïÊí≠Êîæ', 'warning');
                    simpleFallbackPlay(opusBuffers);
                    isPlaying = false;
                    return;
                }

                // ËøûÊé•ÊâÄÊúâPCMÊï∞ÊçÆ
                const totalSamples = pcmData.reduce((acc, arr) => acc + arr.length, 0);
                log(`ÊÄªÂÖ±Ëß£Á†ÅÂá∫ ${totalSamples} ‰∏™PCMÊ†∑Êú¨`, 'debug');

                const combinedPCM = new Float32Array(totalSamples);

                let offset = 0;
                for (const buffer of pcmData) {
                    combinedPCM.set(buffer, offset);
                    offset += buffer.length;
                }

                // ‰ΩøÁî®Web Audio APIÊí≠ÊîæPCMÊï∞ÊçÆ
                const audioBuffer = audioContext.createBuffer(1, combinedPCM.length, 16000);
                audioBuffer.getChannelData(0).set(combinedPCM);

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);

                source.onended = () => {
                    isPlaying = false;
                    log('Èü≥È¢ëÊí≠ÊîæÂÆåÊàê', 'debug');

                    // Êí≠ÊîæÈòüÂàó‰∏≠ÁöÑ‰∏ã‰∏Ä‰∏™
                    if (audioQueue.length > 0) {
                        const nextBuffers = audioQueue.shift();
                        playOpusData(nextBuffers);
                    }
                };

                source.start();
                log(`ÂºÄÂßãÊí≠ÊîæPCMÈü≥È¢ëÔºåÊó∂Èïø: ${(combinedPCM.length / 16000).toFixed(2)}Áßí`, 'debug');

            } catch (error) {
                log(`Êí≠ÊîæOpusÈü≥È¢ëÈîôËØØ: ${error.message}ÔºåÂ∞ùËØï‰ΩøÁî®ÁÆÄÂçïÊí≠Êîæ`, 'error');
                simpleFallbackPlay(opusBuffers);
                isPlaying = false;
            }
        }

        // ÁÆÄÂçïÊí≠ÊîæÂõûÈÄÄÊñπÊ°à
        function simpleFallbackPlay(opusBuffers) {
            try {
                log('‰ΩøÁî®ÁÆÄÂçïÊí≠ÊîæÂõûÈÄÄÊñπÊ°à', 'warning');

                // ÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑ"Êª¥"Â£∞‰Ωú‰∏∫ÂèçÈ¶à
                if (audioContext) {
                    const oscillator = audioContext.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4Èü≥

                    const gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // ËÆæÁΩÆÈü≥Èáè‰∏∫0.1

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2); // Êí≠Êîæ0.2Áßí

                    log('Êí≠ÊîæÊèêÁ§∫Èü≥‰Ωú‰∏∫Èü≥È¢ëÊí≠ÊîæÂ§±Ë¥•ÁöÑÂèçÈ¶à', 'info');
                }
            } catch (error) {
                log(`ÁÆÄÂçïÊí≠ÊîæÂõûÈÄÄÊñπÊ°à‰πüÂ§±Ë¥•: ${error.message}`, 'error');
            }
        }

        // ÂàùÂßãÂåñÈü≥È¢ëÂΩïÂà∂ÂíåÂ§ÑÁêÜ 
        async function initAudio() {
            try {
                // ËØ∑Ê±ÇÈ∫¶ÂÖãÈ£éÊùÉÈôê
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000,  // Á°Æ‰øù16kHzÈááÊ†∑Áéá
                        channelCount: 1     // Á°Æ‰øùÂçïÂ£∞ÈÅì
                    }
                });
                log('Â∑≤Ëé∑ÂèñÈ∫¶ÂÖãÈ£éËÆøÈóÆÊùÉÈôê', 'success');

                // ÂàõÂª∫Èü≥È¢ë‰∏ä‰∏ãÊñá
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,  // Á°Æ‰øùÈááÊ†∑Áéá‰∏éÊúçÂä°Âô®ÊúüÊúõÁöÑ‰∏ÄËá¥
                    latencyHint: 'interactive'
                });
                const source = audioContext.createMediaStreamSource(stream);

                // Ëé∑ÂèñÂÆûÈôÖÈü≥È¢ëËΩ®ÈÅìËÆæÁΩÆ
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    const settings = track.getSettings();
                    log(`ÂÆûÈôÖÈ∫¶ÂÖãÈ£éËÆæÁΩÆ - ÈááÊ†∑Áéá: ${settings.sampleRate || 'Êú™Áü•'}Hz, Â£∞ÈÅìÊï∞: ${settings.channelCount || 'Êú™Áü•'}`, 'info');
                }

                // ÂàõÂª∫ÂàÜÊûêÂô®Áî®‰∫éÂèØËßÜÂåñ
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);

                // Â∞ùËØïÂàùÂßãÂåñMediaRecorderÔºåÊåâ‰ºòÂÖàÁ∫ßÂ∞ùËØï‰∏çÂêåÁºñÁ†ÅÈÄâÈ°π
                try {
                    // ‰ºòÂÖàÂ∞ùËØï‰ΩøÁî®OpusÁºñÁ†Å
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus',
                        audioBitsPerSecond: 16000
                    });
                    log('Â∑≤ÂàùÂßãÂåñMediaRecorder (‰ΩøÁî®OpusÁºñÁ†Å)', 'success');
                    log(`ÈÄâÊã©ÁöÑÁºñÁ†ÅÊ†ºÂºè: ${mediaRecorder.mimeType}`, 'info');
                } catch (e1) {
                    try {
                        // Â¶ÇÊûúOpus‰∏çÊîØÊåÅÔºåÂ∞ùËØïMP3
                        mediaRecorder = new MediaRecorder(stream, {
                            mimeType: 'audio/webm',
                            audioBitsPerSecond: 16000
                        });
                        log('Â∑≤ÂàùÂßãÂåñMediaRecorder (‰ΩøÁî®WebMÊ†áÂáÜÁºñÁ†ÅÔºåOpus‰∏çÊîØÊåÅ)', 'warning');
                        log(`ÈÄâÊã©ÁöÑÁºñÁ†ÅÊ†ºÂºè: ${mediaRecorder.mimeType}`, 'info');
                    } catch (e2) {
                        try {
                            // Â∞ùËØïÂÖ∂‰ªñÂ§áÈÄâÊ†ºÂºè
                            mediaRecorder = new MediaRecorder(stream, {
                                mimeType: 'audio/ogg;codecs=opus',
                                audioBitsPerSecond: 16000
                            });
                            log('Â∑≤ÂàùÂßãÂåñMediaRecorder (‰ΩøÁî®OGG+OpusÁºñÁ†Å)', 'warning');
                            log(`ÈÄâÊã©ÁöÑÁºñÁ†ÅÊ†ºÂºè: ${mediaRecorder.mimeType}`, 'info');
                        } catch (e3) {
                            // ÊúÄÂêé‰ΩøÁî®ÈªòËÆ§ÁºñÁ†Å
                            mediaRecorder = new MediaRecorder(stream);
                            log(`Â∑≤ÂàùÂßãÂåñMediaRecorder (‰ΩøÁî®ÈªòËÆ§ÁºñÁ†Å: ${mediaRecorder.mimeType})`, 'warning');
                        }
                    }
                }

                // Â§ÑÁêÜÂΩïÂà∂ÁöÑÊï∞ÊçÆ
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                // ÂΩïÂà∂ÁªìÊùüÂêéÂ§ÑÁêÜÊï∞ÊçÆ
                mediaRecorder.onstop = async () => {
                    // ÂÅúÊ≠¢ÂèØËßÜÂåñ
                    if (visualizationRequest) {
                        cancelAnimationFrame(visualizationRequest);
                        visualizationRequest = null;
                    }

                    log(`ÂΩïÈü≥ÁªìÊùüÔºåÂ∑≤Êî∂ÈõÜÁöÑÈü≥È¢ëÂùóÊï∞Èáè: ${audioChunks.length}`, 'info');
                    if (audioChunks.length === 0) {
                        log('Ë≠¶ÂëäÔºöÊ≤°ÊúâÊî∂ÈõÜÂà∞‰ªª‰ΩïÈü≥È¢ëÊï∞ÊçÆÔºåËØ∑Ê£ÄÊü•È∫¶ÂÖãÈ£éÊòØÂê¶Â∑•‰ΩúÊ≠£Â∏∏', 'error');
                        return;
                    }

                    // ÂàõÂª∫ÂÆåÊï¥ÁöÑÂΩïÈü≥blob
                    const blob = new Blob(audioChunks, { type: audioChunks[0].type });
                    log(`Â∑≤ÂàõÂª∫Èü≥È¢ëBlobÔºåMIMEÁ±ªÂûã: ${audioChunks[0].type}ÔºåÂ§ßÂ∞è: ${(blob.size / 1024).toFixed(2)} KB`, 'info');

                    // ‰øùÂ≠òÂéüÂßãÂùóÔºå‰ª•Èò≤Ê∏ÖÁ©∫ÂêéÈúÄË¶ÅË∞ÉËØï
                    const chunks = [...audioChunks];
                    audioChunks = [];

                    try {
                        // Â∞ÜblobËΩ¨Êç¢‰∏∫ArrayBuffer
                        const arrayBuffer = await blob.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);

                        log(`Â∑≤ËΩ¨Êç¢‰∏∫Uint8ArrayÔºåÂáÜÂ§áÂèëÈÄÅÔºåÂ§ßÂ∞è: ${(arrayBuffer.byteLength / 1024).toFixed(2)} KB`, 'info');

                        // Ê£ÄÊü•WebSocketÁä∂ÊÄÅ
                        if (!websocket) {
                            log('ÈîôËØØÔºöWebSocketËøûÊé•‰∏çÂ≠òÂú®', 'error');
                            return;
                        }

                        if (websocket.readyState !== WebSocket.OPEN) {
                            log(`ÈîôËØØÔºöWebSocketËøûÊé•Êú™ÊâìÂºÄÔºåÂΩìÂâçÁä∂ÊÄÅ: ${websocket.readyState}`, 'error');
                            return;
                        }

                        // Áõ¥Êé•ÂèëÈÄÅ‰∫åËøõÂà∂Èü≥È¢ëÊï∞ÊçÆ - ËøôÊòØÊúÄÁÆÄÂçïÊúâÊïàÁöÑÊñπÂºè
                        try {
                            // Ê≥®ÊÑèÔºöÂºÄÂßãÂíåÁªìÊùüÊ∂àÊÅØÂ∑≤Âú®ÂΩïÈü≥ÂºÄÂßãÂíåÁªìÊùüÊó∂ÂèëÈÄÅ
                            // ËøôÈáåÂè™ÈúÄË¶ÅÂèëÈÄÅÈü≥È¢ëÊï∞ÊçÆ
                            await new Promise(resolve => setTimeout(resolve, 50));

                            // Â§ÑÁêÜWebMÂÆπÂô®Ê†ºÂºèÔºåÊèêÂèñÁ∫ØOpusÊï∞ÊçÆ
                            // ÊúçÂä°Âô®‰ΩøÁî®opuslib_next.DecoderÔºåÈúÄË¶ÅÁ∫ØOpusÂ∏ß
                            log('Ê≠£Âú®Â§ÑÁêÜÈü≥È¢ëÊï∞ÊçÆÔºåÊèêÂèñÁ∫ØOpusÂ∏ß...', 'info');
                            const opusData = extractOpusFrames(uint8Array);

                            // ËÆ∞ÂΩïOpusÊï∞ÊçÆÂ§ßÂ∞è
                            log(`Â∑≤ÊèêÂèñOpusÊï∞ÊçÆÔºåÂ§ßÂ∞è: ${(opusData.byteLength / 1024).toFixed(2)} KB`, 'info');

                            // ÂèëÈÄÅÈü≥È¢ëÊ∂àÊÅØÁ¨¨‰∫åÊ≠•Ôºö‰∫åËøõÂà∂Èü≥È¢ëÊï∞ÊçÆ
                            websocket.send(opusData);
                            log(`Â∑≤ÂèëÈÄÅOpusÈü≥È¢ëÊï∞ÊçÆ: ${(opusData.byteLength / 1024).toFixed(2)} KB`, 'success');
                        } catch (error) {
                            log(`Èü≥È¢ëÊï∞ÊçÆÂèëÈÄÅÂ§±Ë¥•: ${error.message}`, 'error');

                            // Â∞ùËØï‰ΩøÁî®base64ÁºñÁ†Å‰Ωú‰∏∫Â§áÈÄâÊñπÊ°à
                            try {
                                log('Â∞ùËØï‰ΩøÁî®base64ÁºñÁ†ÅÊñπÂºèÂèëÈÄÅ...', 'info');
                                const base64Data = arrayBufferToBase64(arrayBuffer);
                                const audioDataMessage = {
                                    type: 'audio',
                                    action: 'data',
                                    format: 'opus',
                                    sample_rate: 16000,
                                    channels: 1,
                                    mime_type: chunks[0].type,
                                    encoding: 'base64',
                                    data: base64Data
                                };
                                websocket.send(JSON.stringify(audioDataMessage));
                                log(`Â∑≤‰ΩøÁî®base64ÁºñÁ†ÅÂèëÈÄÅÈü≥È¢ëÊï∞ÊçÆ: ${(arrayBuffer.byteLength / 1024).toFixed(2)} KB`, 'warning');
                            } catch (base64Error) {
                                log(`ÊâÄÊúâÊï∞ÊçÆÂèëÈÄÅÊñπÂºèÂùáÂ§±Ë¥•: ${base64Error.message}`, 'error');
                            }
                        }
                    } catch (error) {
                        log(`Â§ÑÁêÜÂΩïÈü≥Êï∞ÊçÆÈîôËØØ: ${error.message}`, 'error');
                    }
                };

                // Â∞ùËØïÂàùÂßãÂåñOpusËß£Á†ÅÂô®
                try {
                    // Ê£ÄÊü•ModuleInstanceÊòØÂê¶Â≠òÂú®ÔºàÊú¨Âú∞Â∫ìÂØºÂá∫ÁöÑÂÖ®Â±ÄÂèòÈáèÔºâ
                    if (typeof window.ModuleInstance === 'undefined') {
                        throw new Error('OpusÂ∫ìÊú™Âä†ËΩΩÔºåModuleInstanceÂØπË±°‰∏çÂ≠òÂú®');
                    }

                    // ÁÆÄÂçïÊµãËØïModuleInstanceÊòØÂê¶ÂèØÁî®
                    if (typeof window.ModuleInstance._opus_decoder_get_size === 'function') {
                        const testSize = window.ModuleInstance._opus_decoder_get_size(1);
                        log(`OpusËß£Á†ÅÂô®ÊµãËØïÊàêÂäüÔºåËß£Á†ÅÂô®Â§ßÂ∞è: ${testSize} Â≠óËäÇ`, 'success');
                    } else {
                        throw new Error('OpusËß£Á†ÅÂáΩÊï∞Êú™ÊâæÂà∞');
                    }
                } catch (err) {
                    log(`OpusËß£Á†ÅÂô®ÂàùÂßãÂåñË≠¶Âëä: ${err.message}ÔºåÂ∞ÜÂú®ÈúÄË¶ÅÊó∂ÈáçËØï`, 'warning');
                }

                log('Èü≥È¢ëÁ≥ªÁªüÂàùÂßãÂåñÂÆåÊàê', 'success');
                return true;
            } catch (error) {
                log(`Èü≥È¢ëÂàùÂßãÂåñÈîôËØØ: ${error.message}`, 'error');
                return false;
            }
        }

        // ÂºÄÂßãÂΩïÈü≥
        function startRecording() {
            if (isRecording) return;

            try {
                // ÊúÄÂ∞èÂΩïÈü≥Êó∂ÈïøÊèêÁ§∫
                log('ËØ∑Ëá≥Â∞ëÂΩïÂà∂1-2ÁßíÈíüÁöÑÈü≥È¢ëÔºåÁ°Æ‰øùÈááÈõÜÂà∞Ë∂≥Â§üÊï∞ÊçÆ', 'info');

                // Ëé∑ÂèñÊúçÂä°Âô®Á±ªÂûã - ‰ªéURLÂà§Êñ≠
                const serverUrl = serverUrlInput.value.trim();
                let isXiaozhiNative = false;

                // Ê£ÄÊü•ÊòØÂê¶ÊòØÂ∞èÊô∫ÂéüÁîüÊúçÂä°Âô® (Ê†πÊçÆURLÁâπÂæÅÂà§Êñ≠)
                if (serverUrl.includes('xiaozhi') || serverUrl.includes('localhost') || serverUrl.includes('127.0.0.1')) {
                    isXiaozhiNative = true;
                    log('Ê£ÄÊµãÂà∞Â∞èÊô∫ÂéüÁîüÊúçÂä°Âô®Ôºå‰ΩøÁî®Ê†áÂáÜlistenÂçèËÆÆ', 'info');
                }

                // ‰ΩøÁî®Áõ¥Êé•PCMÂΩïÈü≥ÂíålibopusÁºñÁ†ÅÁöÑÊñπÂºè
                startDirectRecording();
            } catch (error) {
                log(`ÂΩïÈü≥ÂêØÂä®ÈîôËØØ: ${error.message}`, 'error');
            }
        }

        // ÂÅúÊ≠¢ÂΩïÈü≥
        function stopRecording() {
            if (!isRecording) return;

            try {
                // ‰ΩøÁî®Áõ¥Êé•PCMÂΩïÈü≥ÂÅúÊ≠¢
                stopDirectRecording();
            } catch (error) {
                log(`ÂÅúÊ≠¢ÂΩïÈü≥ÈîôËØØ: ${error.message}`, 'error');
            }
        }

        // ËøûÊé•WebSocketÊúçÂä°Âô®
        function connectToServer() {
            const url = serverUrlInput.value.trim();
            if (url === '') return;

            try {
                // Ê£ÄÊü•URLÊ†ºÂºè
                if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                    log('URLÊ†ºÂºèÈîôËØØÔºåÂøÖÈ°ª‰ª•ws://Êàñwss://ÂºÄÂ§¥', 'error');
                    return;
                }

                // ‰ΩøÁî®Ëá™ÂÆö‰πâWebSocketÂÆûÁé∞‰ª•Ê∑ªÂä†ËÆ§ËØÅÂ§¥‰ø°ÊÅØ
                // Ê≥®ÊÑèÔºöÊµèËßàÂô®ÂéüÁîüWebSocket‰∏çÊîØÊåÅËá™ÂÆö‰πâÂ§¥ÔºåÈúÄË¶ÅÈÄöËøáÊúçÂä°Âô®Ê∑ªÂä†‰∏Ä‰∏™‰ª£ÁêÜÂ±Ç
                // ‰ΩÜÊàë‰ª¨ÂèØ‰ª•ÈÄöËøáURLÂèÇÊï∞Ê®°ÊãüËÆ§ËØÅ‰ø°ÊÅØ
                let connUrl = new URL(url);

                // Ê∑ªÂä†ËÆ§ËØÅÂèÇÊï∞
                connUrl.searchParams.append('device_id', 'web_test_device');
                connUrl.searchParams.append('device_mac', '00:11:22:33:44:55');

                log(`Ê≠£Âú®ËøûÊé•: ${connUrl.toString()}`, 'info');
                websocket = new WebSocket(connUrl.toString());

                // ËÆæÁΩÆÊé•Êî∂‰∫åËøõÂà∂Êï∞ÊçÆÁöÑÁ±ªÂûã‰∏∫ArrayBuffer
                websocket.binaryType = 'arraybuffer';

                websocket.onopen = async () => {
                    log(`Â∑≤ËøûÊé•Âà∞ÊúçÂä°Âô®: ${url}`, 'success');
                    connectionStatus.textContent = 'Â∑≤ËøûÊé•';
                    connectionStatus.style.color = 'green';

                    // ËøûÊé•ÊàêÂäüÂêéÂèëÈÄÅhelloÊ∂àÊÅØ
                    await sendHelloMessage();

                    connectButton.textContent = 'Êñ≠ÂºÄ';
                    connectButton.onclick = disconnectFromServer;
                    messageInput.disabled = false;
                    sendTextButton.disabled = false;

                    const audioInitialized = await initAudio();
                    if (audioInitialized) {
                        recordButton.disabled = false;
                    }
                };

                websocket.onclose = () => {
                    log('Â∑≤Êñ≠ÂºÄËøûÊé•', 'info');
                    connectionStatus.textContent = 'Â∑≤Êñ≠ÂºÄ';
                    connectionStatus.style.color = 'red';

                    connectButton.textContent = 'ËøûÊé•';
                    connectButton.onclick = connectToServer;
                    messageInput.disabled = true;
                    sendTextButton.disabled = true;
                    recordButton.disabled = true;
                    stopButton.disabled = true;
                };

                websocket.onerror = (error) => {
                    log(`WebSocketÈîôËØØ: ${error.message || 'Êú™Áü•ÈîôËØØ'}`, 'error');
                    connectionStatus.textContent = 'ËøûÊé•ÈîôËØØ';
                    connectionStatus.style.color = 'red';
                };

                websocket.onmessage = function (event) {
                    try {
                        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊñáÊú¨Ê∂àÊÅØ
                        if (typeof event.data === 'string') {
                            const message = JSON.parse(event.data);

                            if (message.type === 'hello') {
                                log(`ÊúçÂä°Âô®ÂõûÂ∫îÔºö${message.message}`, 'info');
                            } else if (message.type === 'tts') {
                                // TTSÁä∂ÊÄÅÊ∂àÊÅØ
                                if (message.state === 'start') {
                                    log('ÊúçÂä°Âô®ÂºÄÂßãÂèëÈÄÅËØ≠Èü≥', 'info');
                                } else if (message.state === 'sentence_start') {
                                    log(`ÊúçÂä°Âô®ÂèëÈÄÅËØ≠Èü≥ÊÆµ: ${message.text}`, 'info');
                                    // Ê∑ªÂä†ÊñáÊú¨Âà∞‰ºöËØùËÆ∞ÂΩï
                                    if (message.text) {
                                        addMessage(message.text);
                                    }
                                } else if (message.state === 'sentence_end') {
                                    log(`ËØ≠Èü≥ÊÆµÁªìÊùü: ${message.text}`, 'info');
                                } else if (message.state === 'stop') {
                                    log('ÊúçÂä°Âô®ËØ≠Èü≥‰º†ËæìÁªìÊùü', 'info');
                                    // ÁªìÊùüÂêéÊõ¥Êñ∞UIÁä∂ÊÄÅ
                                    if (recordButton.disabled) {
                                        recordButton.disabled = false;
                                        recordButton.textContent = 'ÂºÄÂßãÂΩïÈü≥';
                                        recordButton.classList.remove('recording');
                                    }
                                }
                            } else if (message.type === 'audio') {
                                // Èü≥È¢ëÊéßÂà∂Ê∂àÊÅØ
                                log(`Êî∂Âà∞Èü≥È¢ëÊéßÂà∂Ê∂àÊÅØ: ${JSON.stringify(message)}`, 'info');
                            } else if (message.type === 'stt') {
                                // ËØ≠Èü≥ËØÜÂà´ÁªìÊûú
                                log(`ËØÜÂà´ÁªìÊûú: ${message.text}`, 'info');
                                // Ê∑ªÂä†ËØÜÂà´ÁªìÊûúÂà∞‰ºöËØùËÆ∞ÂΩï
                                addMessage(`[ËØ≠Èü≥ËØÜÂà´] ${message.text}`, true);
                            } else if (message.type === 'llm') {
                                // Â§ßÊ®°ÂûãÂõûÂ§ç
                                log(`Â§ßÊ®°ÂûãÂõûÂ§ç: ${message.text}`, 'info');
                                // Ê∑ªÂä†Â§ßÊ®°ÂûãÂõûÂ§çÂà∞‰ºöËØùËÆ∞ÂΩï
                                if (message.text && message.text !== 'üòä') {
                                    addMessage(message.text);
                                }
                            } else {
                                // Êú™Áü•Ê∂àÊÅØÁ±ªÂûã
                                log(`Êú™Áü•Ê∂àÊÅØÁ±ªÂûã: ${message.type}`, 'info');
                                addMessage(JSON.stringify(message, null, 2));
                            }
                        } else {
                            // Â§ÑÁêÜ‰∫åËøõÂà∂Êï∞ÊçÆ - ÂÖºÂÆπÂ§öÁßç‰∫åËøõÂà∂Ê†ºÂºè
                            handleBinaryMessage(event.data);
                        }
                    } catch (error) {
                        log(`WebSocketÊ∂àÊÅØÂ§ÑÁêÜÈîôËØØ: ${error.message}`, 'error');
                        // ÈùûJSONÊ†ºÂºèÊñáÊú¨Ê∂àÊÅØÁõ¥Êé•ÊòæÁ§∫
                        if (typeof event.data === 'string') {
                            addMessage(event.data);
                        }
                    }
                };

                connectionStatus.textContent = 'Ê≠£Âú®ËøûÊé•...';
                connectionStatus.style.color = 'orange';
            } catch (error) {
                log(`ËøûÊé•ÈîôËØØ: ${error.message}`, 'error');
                connectionStatus.textContent = 'ËøûÊé•Â§±Ë¥•';
            }
        }

        // ÂèëÈÄÅhelloÊè°ÊâãÊ∂àÊÅØ
        async function sendHelloMessage() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) return;

            try {
                // ËÆæÁΩÆËÆæÂ§á‰ø°ÊÅØ
                const helloMessage = {
                    type: 'hello',
                    device_id: 'web_test_device',
                    device_name: 'WebÊµãËØïËÆæÂ§á',
                    device_mac: '00:11:22:33:44:55',
                    token: 'your-token1' // ‰ΩøÁî®config.yaml‰∏≠ÈÖçÁΩÆÁöÑtoken
                };

                log('ÂèëÈÄÅhelloÊè°ÊâãÊ∂àÊÅØ', 'info');
                websocket.send(JSON.stringify(helloMessage));

                // Á≠âÂæÖÊúçÂä°Âô®ÂìçÂ∫î
                return new Promise(resolve => {
                    // 5ÁßíË∂ÖÊó∂
                    const timeout = setTimeout(() => {
                        log('Á≠âÂæÖhelloÂìçÂ∫îË∂ÖÊó∂', 'error');
                        log('ÊèêÁ§∫: ËØ∑Â∞ùËØïÁÇπÂáª"ÊµãËØïËÆ§ËØÅ"ÊåâÈíÆËøõË°åËøûÊé•ÊéíÊü•', 'info');
                        resolve(false);
                    }, 5000);

                    // ‰∏¥Êó∂ÁõëÂê¨‰∏ÄÊ¨°Ê∂àÊÅØÔºåÊé•Êî∂helloÂìçÂ∫î
                    const onMessageHandler = (event) => {
                        try {
                            const response = JSON.parse(event.data);
                            if (response.type === 'hello' && response.session_id) {
                                log(`ÊúçÂä°Âô®Êè°ÊâãÊàêÂäüÔºå‰ºöËØùID: ${response.session_id}`, 'success');
                                clearTimeout(timeout);
                                websocket.removeEventListener('message', onMessageHandler);
                                resolve(true);
                            }
                        } catch (e) {
                            // ÂøΩÁï•ÈùûJSONÊ∂àÊÅØ
                        }
                    };

                    websocket.addEventListener('message', onMessageHandler);
                });
            } catch (error) {
                log(`ÂèëÈÄÅhelloÊ∂àÊÅØÈîôËØØ: ${error.message}`, 'error');
                return false;
            }
        }

        // Êñ≠ÂºÄWebSocketËøûÊé•
        function disconnectFromServer() {
            if (!websocket) return;

            websocket.close();
            stopRecording();
        }

        // ÂèëÈÄÅÊñáÊú¨Ê∂àÊÅØ
        function sendTextMessage() {
            const message = messageInput.value.trim();
            if (message === '' || !websocket || websocket.readyState !== WebSocket.OPEN) return;

            try {
                // Áõ¥Êé•ÂèëÈÄÅlistenÊ∂àÊÅØÔºå‰∏çÈúÄË¶ÅÈáçÂ§çÂèëÈÄÅhello
                const listenMessage = {
                    type: 'listen',
                    mode: 'manual',
                    state: 'detect',
                    text: message
                };

                websocket.send(JSON.stringify(listenMessage));
                addMessage(message, true);
                log(`ÂèëÈÄÅÊñáÊú¨Ê∂àÊÅØ: ${message}`, 'info');

                messageInput.value = '';
            } catch (error) {
                log(`ÂèëÈÄÅÊ∂àÊÅØÈîôËØØ: ${error.message}`, 'error');
            }
        }

        // ÂàùÂßãÂåñ‰∫ã‰ª∂ÁõëÂê¨Âô®
        function initEventListeners() {
            connectButton.addEventListener('click', connectToServer);
            document.getElementById('authTestButton').addEventListener('click', testAuthentication);

            // Ê†áÁ≠æÈ°µÂàáÊç¢
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // ÁßªÈô§ÊâÄÊúâÊ†áÁ≠æÈ°µÁöÑactiveÁ±ª
                    tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                    // Ê∑ªÂä†ÂΩìÂâçÊ†áÁ≠æÈ°µÁöÑactiveÁ±ª
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}Tab`).classList.add('active');
                });
            });

            sendTextButton.addEventListener('click', sendTextMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendTextMessage();
            });

            recordButton.addEventListener('click', () => {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });

            window.addEventListener('resize', initVisualizer);
        }

        // ÊµãËØïËÆ§ËØÅ
        async function testAuthentication() {
            log('ÂºÄÂßãÊµãËØïËÆ§ËØÅ...', 'info');

            // ÊòæÁ§∫ÊúçÂä°Âô®ÈÖçÁΩÆ
            log('-------- ÊúçÂä°Âô®ËÆ§ËØÅÈÖçÁΩÆÊ£ÄÊü• --------', 'info');
            log('ËØ∑Á°ÆËÆ§config.yaml‰∏≠ÁöÑauthÈÖçÁΩÆÔºö', 'info');
            log('1. server.auth.enabled ‰∏∫ false ÊàñÊúçÂä°Âô®Â∑≤Ê≠£Á°ÆÈÖçÁΩÆËÆ§ËØÅ', 'info');
            log('2. Â¶ÇÊûúÂêØÁî®‰∫ÜËÆ§ËØÅÔºåËØ∑Á°ÆËÆ§‰ΩøÁî®‰∫ÜÊ≠£Á°ÆÁöÑtoken', 'info');
            log('3. ÊàñËÄÖÂú®allowed_devices‰∏≠Ê∑ªÂä†‰∫ÜÊµãËØïËÆæÂ§áMACÔºö00:11:22:33:44:55', 'info');

            const serverUrl = serverUrlInput.value.trim();
            if (!serverUrl) {
                log('ËØ∑ËæìÂÖ•ÊúçÂä°Âô®Âú∞ÂùÄ', 'error');
                return;
            }

            // ÊµãËØïËøûÊé•
            log('Â∞ùËØï‰∏çÂêåËÆ§ËØÅÂèÇÊï∞ÁöÑËøûÊé•Ôºö', 'info');

            // ÊµãËØï1: Êó†ÂèÇÊï∞ËøûÊé•
            try {
                log('ÊµãËØï1: Â∞ùËØïÊó†ÂèÇÊï∞ËøûÊé•...', 'info');
                const ws1 = new WebSocket(serverUrl);

                ws1.onopen = () => {
                    log('ÊµãËØï1ÊàêÂäü: Êó†ÂèÇÊï∞ÂèØËøûÊé•ÔºåÊúçÂä°Âô®ÂèØËÉΩÊ≤°ÊúâÂêØÁî®ËÆ§ËØÅ', 'success');
                    ws1.close();
                };

                ws1.onerror = (error) => {
                    log('ÊµãËØï1Â§±Ë¥•: Êó†ÂèÇÊï∞ËøûÊé•Ë¢´ÊãíÁªùÔºåÊúçÂä°Âô®ÂèØËÉΩÂêØÁî®‰∫ÜËÆ§ËØÅ', 'error');
                };

                // 5ÁßíÂêéÂÖ≥Èó≠ÊµãËØïËøûÊé•
                setTimeout(() => {
                    if (ws1.readyState === WebSocket.CONNECTING || ws1.readyState === WebSocket.OPEN) {
                        ws1.close();
                    }
                }, 5000);
            } catch (error) {
                log(`ÊµãËØï1Âá∫Èîô: ${error.message}`, 'error');
            }

            // ÊµãËØï2: Â∏¶ÂèÇÊï∞ËøûÊé•
            setTimeout(async () => {
                try {
                    log('ÊµãËØï2: Â∞ùËØïÂ∏¶tokenÂèÇÊï∞ËøûÊé•...', 'info');

                    let url = new URL(serverUrl);
                    url.searchParams.append('token', 'your-token1');
                    url.searchParams.append('device_id', 'web_test_device');
                    url.searchParams.append('device_mac', '00:11:22:33:44:55');

                    const ws2 = new WebSocket(url.toString());

                    ws2.onopen = () => {
                        log('ÊµãËØï2ÊàêÂäü: Â∏¶tokenÂèÇÊï∞ÂèØËøûÊé•', 'success');

                        // Â∞ùËØïÂèëÈÄÅhelloÊ∂àÊÅØ
                        const helloMsg = {
                            type: 'hello',
                            device_id: 'web_test_device',
                            device_mac: '00:11:22:33:44:55',
                            token: 'your-token1'
                        };

                        ws2.send(JSON.stringify(helloMsg));
                        log('Â∑≤ÂèëÈÄÅhelloÊµãËØïÊ∂àÊÅØ', 'info');

                        // ÁõëÂê¨ÂìçÂ∫î
                        ws2.onmessage = (event) => {
                            try {
                                const response = JSON.parse(event.data);
                                if (response.type === 'hello' && response.session_id) {
                                    log(`ÊµãËØïÂÆåÂÖ®ÊàêÂäü! Êî∂Âà∞helloÂìçÂ∫îÔºå‰ºöËØùID: ${response.session_id}`, 'success');
                                    ws2.close();
                                }
                            } catch (e) {
                                log(`Êî∂Âà∞ÈùûJSONÂìçÂ∫î: ${event.data}`, 'info');
                            }
                        };

                        // 5ÁßíÂêéÂÖ≥Èó≠
                        setTimeout(() => ws2.close(), 5000);
                    };

                    ws2.onerror = (error) => {
                        log('ÊµãËØï2Â§±Ë¥•: Â∏¶tokenÂèÇÊï∞ËøûÊé•Ë¢´ÊãíÁªù', 'error');
                        log('ËØ∑Ê£ÄÊü•tokenÊòØÂê¶Ê≠£Á°ÆÔºåÊàñÊúçÂä°Âô®ÊòØÂê¶Êé•ÂèóURLÂèÇÊï∞ËÆ§ËØÅ', 'error');
                    };
                } catch (error) {
                    log(`ÊµãËØï2Âá∫Èîô: ${error.message}`, 'error');
                }
            }, 6000);

            log('ËÆ§ËØÅÊµãËØïÂ∑≤ÂêØÂä®ÔºåËØ∑Êü•ÁúãÊµãËØïÁªìÊûú...', 'info');
        }

        // Â∏ÆÂä©ÂáΩÊï∞ÔºöArrayBufferËΩ¨Base64
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // ‰ΩøÁî®libopusÂàõÂª∫‰∏Ä‰∏™OpusÁºñÁ†ÅÂô®
        let opusEncoder = null;
        function initOpusEncoder() {
            try {
                if (opusEncoder) {
                    return true; // Â∑≤ÁªèÂàùÂßãÂåñËøá
                }

                if (!window.ModuleInstance) {
                    log('Êó†Ê≥ïÂàõÂª∫OpusÁºñÁ†ÅÂô®ÔºöModuleInstance‰∏çÂèØÁî®', 'error');
                    return false;
                }

                // ÂàùÂßãÂåñ‰∏Ä‰∏™OpusÁºñÁ†ÅÂô®
                const mod = window.ModuleInstance;
                const sampleRate = 16000; // 16kHzÈááÊ†∑Áéá
                const channels = 1;       // ÂçïÂ£∞ÈÅì
                const application = 2048; // OPUS_APPLICATION_VOIP = 2048

                // ÂàõÂª∫ÁºñÁ†ÅÂô®
                opusEncoder = {
                    channels: channels,
                    sampleRate: sampleRate,
                    frameSize: 960, // 60ms @ 16kHz = 60 * 16 = 960 samples
                    maxPacketSize: 4000, // ÊúÄÂ§ßÂåÖÂ§ßÂ∞è
                    module: mod,

                    // ÂàùÂßãÂåñÁºñÁ†ÅÂô®
                    init: function () {
                        try {
                            // Ëé∑ÂèñÁºñÁ†ÅÂô®Â§ßÂ∞è
                            const encoderSize = mod._opus_encoder_get_size(this.channels);
                            log(`OpusÁºñÁ†ÅÂô®Â§ßÂ∞è: ${encoderSize}Â≠óËäÇ`, 'info');

                            // ÂàÜÈÖçÂÜÖÂ≠ò
                            this.encoderPtr = mod._malloc(encoderSize);
                            if (!this.encoderPtr) {
                                throw new Error("Êó†Ê≥ïÂàÜÈÖçÁºñÁ†ÅÂô®ÂÜÖÂ≠ò");
                            }

                            // ÂàùÂßãÂåñÁºñÁ†ÅÂô®
                            const err = mod._opus_encoder_init(
                                this.encoderPtr,
                                this.sampleRate,
                                this.channels,
                                application
                            );

                            if (err < 0) {
                                throw new Error(`OpusÁºñÁ†ÅÂô®ÂàùÂßãÂåñÂ§±Ë¥•: ${err}`);
                            }

                            // ËÆæÁΩÆ‰ΩçÁéá (16kbps)
                            mod._opus_encoder_ctl(this.encoderPtr, 4002, 16000); // OPUS_SET_BITRATE

                            // ËÆæÁΩÆÂ§çÊùÇÂ∫¶ (0-10, Ë∂äÈ´òË¥®ÈáèË∂äÂ•Ω‰ΩÜCPU‰ΩøÁî®Ë∂äÂ§ö)
                            mod._opus_encoder_ctl(this.encoderPtr, 4010, 5);     // OPUS_SET_COMPLEXITY

                            // ËÆæÁΩÆ‰ΩøÁî®DTX (‰∏ç‰º†ËæìÈùôÈü≥Â∏ß)
                            mod._opus_encoder_ctl(this.encoderPtr, 4016, 1);     // OPUS_SET_DTX

                            log("OpusÁºñÁ†ÅÂô®ÂàùÂßãÂåñÊàêÂäü", 'success');
                            return true;
                        } catch (error) {
                            if (this.encoderPtr) {
                                mod._free(this.encoderPtr);
                                this.encoderPtr = null;
                            }
                            log(`OpusÁºñÁ†ÅÂô®ÂàùÂßãÂåñÂ§±Ë¥•: ${error.message}`, 'error');
                            return false;
                        }
                    },

                    // ÁºñÁ†ÅPCMÊï∞ÊçÆ‰∏∫Opus
                    encode: function (pcmData) {
                        if (!this.encoderPtr) {
                            if (!this.init()) {
                                return null;
                            }
                        }

                        try {
                            const mod = this.module;

                            // ‰∏∫PCMÊï∞ÊçÆÂàÜÈÖçÂÜÖÂ≠ò
                            const pcmPtr = mod._malloc(pcmData.length * 2); // 2Â≠óËäÇ/int16

                            // Â∞ÜPCMÊï∞ÊçÆÂ§çÂà∂Âà∞HEAP
                            for (let i = 0; i < pcmData.length; i++) {
                                mod.HEAP16[(pcmPtr >> 1) + i] = pcmData[i];
                            }

                            // ‰∏∫ËæìÂá∫ÂàÜÈÖçÂÜÖÂ≠ò
                            const outPtr = mod._malloc(this.maxPacketSize);

                            // ËøõË°åÁºñÁ†Å
                            const encodedLen = mod._opus_encode(
                                this.encoderPtr,
                                pcmPtr,
                                this.frameSize,
                                outPtr,
                                this.maxPacketSize
                            );

                            if (encodedLen < 0) {
                                throw new Error(`OpusÁºñÁ†ÅÂ§±Ë¥•: ${encodedLen}`);
                            }

                            // Â§çÂà∂ÁºñÁ†ÅÂêéÁöÑÊï∞ÊçÆ
                            const opusData = new Uint8Array(encodedLen);
                            for (let i = 0; i < encodedLen; i++) {
                                opusData[i] = mod.HEAPU8[outPtr + i];
                            }

                            // ÈáäÊîæÂÜÖÂ≠ò
                            mod._free(pcmPtr);
                            mod._free(outPtr);

                            return opusData;
                        } catch (error) {
                            log(`OpusÁºñÁ†ÅÂá∫Èîô: ${error.message}`, 'error');
                            return null;
                        }
                    },

                    // ÈîÄÊØÅÁºñÁ†ÅÂô®
                    destroy: function () {
                        if (this.encoderPtr) {
                            this.module._free(this.encoderPtr);
                            this.encoderPtr = null;
                        }
                    }
                };

                const result = opusEncoder.init();
                return result;
            } catch (error) {
                log(`ÂàõÂª∫OpusÁºñÁ†ÅÂô®Â§±Ë¥•: ${error.message}`, 'error');
                return false;
            }
        }

        // ÂàùÂßãÂåñÂ∫îÁî®
        function initApp() {
            initVisualizer();
            initEventListeners();

            // Ê£ÄÊü•libopus.jsÊòØÂê¶Ê≠£Á°ÆÂä†ËΩΩ
            checkOpusLoaded();

            // ÂàùÂßãÂåñOpusÁºñÁ†ÅÂô®
            initOpusEncoder();
        }

        // PCMÂΩïÈü≥Â§ÑÁêÜÂô®‰ª£Á†Å - ‰ºöË¢´Ê≥®ÂÖ•Âà∞AudioWorklet‰∏≠
        const audioProcessorCode = `
            class AudioRecorderProcessor extends AudioWorkletProcessor {
                constructor() {
                    super();
                    this.buffers = [];
                    this.frameSize = 960; // 60ms @ 16kHz = 960 samples
                    this.buffer = new Int16Array(this.frameSize);
                    this.bufferIndex = 0;
                    this.isRecording = false;
                    
                    // ÁõëÂê¨Êù•Ëá™‰∏ªÁ∫øÁ®ãÁöÑÊ∂àÊÅØ
                    this.port.onmessage = (event) => {
                        if (event.data.command === 'start') {
                            this.isRecording = true;
                            this.port.postMessage({ type: 'status', status: 'started' });
                        } else if (event.data.command === 'stop') {
                            this.isRecording = false;
                            
                            // ÂèëÈÄÅÂâ©‰ΩôÁöÑÁºìÂÜ≤Âå∫
                            if (this.bufferIndex > 0) {
                                const finalBuffer = this.buffer.slice(0, this.bufferIndex);
                                this.port.postMessage({
                                    type: 'buffer',
                                    buffer: finalBuffer
                                });
                                this.bufferIndex = 0;
                            }
                            
                            this.port.postMessage({ type: 'status', status: 'stopped' });
                        }
                    };
                }
                
                process(inputs, outputs, parameters) {
                    if (!this.isRecording) return true;
                    
                    const input = inputs[0][0]; // Ëé∑ÂèñÁ¨¨‰∏Ä‰∏™ËæìÂÖ•ÈÄöÈÅì
                    if (!input) return true;
                    
                    // Â∞ÜÊµÆÁÇπÈááÊ†∑ËΩ¨Êç¢‰∏∫16‰ΩçÊï¥Êï∞Âπ∂Â≠òÂÇ®
                    for (let i = 0; i < input.length; i++) {
                        if (this.bufferIndex >= this.frameSize) {
                            // ÁºìÂÜ≤Âå∫Â∑≤Êª°ÔºåÂèëÈÄÅÁªô‰∏ªÁ∫øÁ®ãÂπ∂ÈáçÁΩÆ
                            this.port.postMessage({
                                type: 'buffer',
                                buffer: this.buffer.slice(0)
                            });
                            this.bufferIndex = 0;
                        }
                        
                        // ËΩ¨Êç¢‰∏∫16‰ΩçÊï¥Êï∞ (-32768Âà∞32767)
                        this.buffer[this.bufferIndex++] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                    }
                    
                    return true;
                }
            }
            
            registerProcessor('audio-recorder-processor', AudioRecorderProcessor);
        `;

        // ÂàõÂª∫Èü≥È¢ëÂ§ÑÁêÜÂô®
        async function createAudioProcessor() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,
                    latencyHint: 'interactive'
                });
            }

            try {
                // Ê£ÄÊü•ÊòØÂê¶ÊîØÊåÅAudioWorklet
                if (audioContext.audioWorklet) {
                    // Ê≥®ÂÜåÈü≥È¢ëÂ§ÑÁêÜÂô®
                    const blob = new Blob([audioProcessorCode], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    await audioContext.audioWorklet.addModule(url);
                    URL.revokeObjectURL(url);

                    // ÂàõÂª∫Èü≥È¢ëÂ§ÑÁêÜËäÇÁÇπ
                    const audioProcessor = new AudioWorkletNode(audioContext, 'audio-recorder-processor');

                    // ËÆæÁΩÆÈü≥È¢ëÂ§ÑÁêÜÊ∂àÊÅØÂ§ÑÁêÜ
                    audioProcessor.port.onmessage = (event) => {
                        if (event.data.type === 'buffer') {
                            // Êî∂Âà∞PCMÁºìÂÜ≤Âå∫Êï∞ÊçÆ
                            processPCMBuffer(event.data.buffer);
                        }
                    };

                    log('‰ΩøÁî®AudioWorkletÂ§ÑÁêÜÈü≥È¢ë', 'success');
                    return { node: audioProcessor, type: 'worklet' };
                } else {
                    // ‰ΩøÁî®ÊóßÁâàScriptProcessorNode‰Ωú‰∏∫ÂõûÈÄÄÊñπÊ°à
                    log('AudioWorklet‰∏çÂèØÁî®Ôºå‰ΩøÁî®ScriptProcessorNode‰Ωú‰∏∫ÂõûÈÄÄÊñπÊ°à', 'warning');

                    const frameSize = 4096; // ScriptProcessorNodeÁºìÂÜ≤Âå∫Â§ßÂ∞è
                    const scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);

                    // Â∞ÜaudioProcess‰∫ã‰ª∂ËÆæÁΩÆ‰∏∫Â§ÑÁêÜÈü≥È¢ëÊï∞ÊçÆ
                    scriptProcessor.onaudioprocess = (event) => {
                        if (!isRecording) return;

                        const input = event.inputBuffer.getChannelData(0);
                        const buffer = new Int16Array(input.length);

                        // Â∞ÜÊµÆÁÇπÊï∞ÊçÆËΩ¨Êç¢‰∏∫16‰ΩçÊï¥Êï∞
                        for (let i = 0; i < input.length; i++) {
                            buffer[i] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                        }

                        // Â§ÑÁêÜPCMÊï∞ÊçÆ
                        processPCMBuffer(buffer);
                    };

                    // ÈúÄË¶ÅËøûÊé•ËæìÂá∫ÔºåÂê¶Âàô‰∏ç‰ºöËß¶ÂèëÂ§ÑÁêÜ
                    // Êàë‰ª¨ÂàõÂª∫‰∏Ä‰∏™ÈùôÈü≥ÈÄöÈÅì
                    const silent = audioContext.createGain();
                    silent.gain.value = 0;
                    scriptProcessor.connect(silent);
                    silent.connect(audioContext.destination);

                    return { node: scriptProcessor, type: 'processor' };
                }
            } catch (error) {
                log(`ÂàõÂª∫Èü≥È¢ëÂ§ÑÁêÜÂô®Â§±Ë¥•: ${error.message}ÔºåÂ∞ùËØïÂõûÈÄÄÊñπÊ°à`, 'error');

                // ÊúÄÂêéÂõûÈÄÄÊñπÊ°àÔºö‰ΩøÁî®ScriptProcessorNode
                try {
                    const frameSize = 4096; // ScriptProcessorNodeÁºìÂÜ≤Âå∫Â§ßÂ∞è
                    const scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);

                    scriptProcessor.onaudioprocess = (event) => {
                        if (!isRecording) return;

                        const input = event.inputBuffer.getChannelData(0);
                        const buffer = new Int16Array(input.length);

                        for (let i = 0; i < input.length; i++) {
                            buffer[i] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                        }

                        processPCMBuffer(buffer);
                    };

                    const silent = audioContext.createGain();
                    silent.gain.value = 0;
                    scriptProcessor.connect(silent);
                    silent.connect(audioContext.destination);

                    log('‰ΩøÁî®ScriptProcessorNode‰Ωú‰∏∫ÂõûÈÄÄÊñπÊ°àÊàêÂäü', 'warning');
                    return { node: scriptProcessor, type: 'processor' };
                } catch (fallbackError) {
                    log(`ÂõûÈÄÄÊñπÊ°à‰πüÂ§±Ë¥•: ${fallbackError.message}`, 'error');
                    return null;
                }
            }
        }

        // ÂàùÂßãÂåñÁõ¥Êé•‰ªéPCMÊï∞ÊçÆÂΩïÈü≥ÁöÑÁ≥ªÁªü
        let audioProcessor = null;
        let audioProcessorType = null;
        let audioSource = null;
        let pcmBuffers = [];

        // Â§ÑÁêÜPCMÁºìÂÜ≤Êï∞ÊçÆ
        let pcmDataBuffer = new Int16Array();
        function processPCMBuffer(buffer) {
            if (!isRecording) return;

            // Â∞ÜÊñ∞ÁöÑPCMÊï∞ÊçÆËøΩÂä†Âà∞ÁºìÂÜ≤Âå∫
            const newBuffer = new Int16Array(pcmDataBuffer.length + buffer.length);
            newBuffer.set(pcmDataBuffer);
            newBuffer.set(buffer, pcmDataBuffer.length);
            pcmDataBuffer = newBuffer;

            // Ê£ÄÊü•ÊòØÂê¶ÊúâË∂≥Â§üÁöÑÊï∞ÊçÆËøõË°åOpusÁºñÁ†ÅÔºà16000Hz, 60ms = 960‰∏™ÈááÊ†∑ÁÇπÔºâ
            const samplesPerFrame = 960; // 60ms @ 16kHz

            while (pcmDataBuffer.length >= samplesPerFrame) {
                // ‰ªéÁºìÂÜ≤Âå∫ÂèñÂá∫‰∏ÄÂ∏ßÊï∞ÊçÆ
                const frameData = pcmDataBuffer.slice(0, samplesPerFrame);
                pcmDataBuffer = pcmDataBuffer.slice(samplesPerFrame);

                // ÁºñÁ†Å‰∏∫Opus
                encodeAndSendOpus(frameData);
            }
        }

        // ÁºñÁ†ÅÂπ∂ÂèëÈÄÅOpusÊï∞ÊçÆ
        function encodeAndSendOpus(pcmData = null) {
            if (!opusEncoder) {
                log('OpusÁºñÁ†ÅÂô®Êú™ÂàùÂßãÂåñ', 'error');
                return;
            }

            try {
                // Â¶ÇÊûúÊèê‰æõ‰∫ÜPCMÊï∞ÊçÆÔºåÂàôÁºñÁ†ÅËØ•Êï∞ÊçÆ
                if (pcmData) {
                    // ‰ΩøÁî®Â∑≤ÂàùÂßãÂåñÁöÑOpusÁºñÁ†ÅÂô®ÁºñÁ†Å
                    const opusData = opusEncoder.encode(pcmData);

                    if (opusData && opusData.length > 0) {
                        // Â≠òÂÇ®Èü≥È¢ëÂ∏ß
                        audioBuffers.push(opusData.buffer);
                        totalAudioSize += opusData.length;

                        // Â¶ÇÊûúWebSocketÂ∑≤ËøûÊé•ÔºåÂàôÂèëÈÄÅÊï∞ÊçÆ
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            try {
                                // ÊúçÂä°Á´ØÊúüÊúõÊé•Êî∂ÂéüÂßãOpusÊï∞ÊçÆÔºå‰∏çÈúÄË¶Å‰ªª‰ΩïÈ¢ùÂ§ñÂåÖË£Ö
                                websocket.send(opusData.buffer);
                                log(`ÂèëÈÄÅOpusÂ∏ßÔºåÂ§ßÂ∞èÔºö${opusData.length}Â≠óËäÇ`, 'debug');
                            } catch (error) {
                                log(`WebSocketÂèëÈÄÅÈîôËØØ: ${error.message}`, 'error');
                            }
                        }
                    } else {
                        log('OpusÁºñÁ†ÅÂ§±Ë¥•ÔºåÊó†ÊúâÊïàÊï∞ÊçÆËøîÂõû', 'error');
                    }
                } else {
                    // Â§ÑÁêÜÂâ©‰ΩôÁöÑPCMÊï∞ÊçÆ
                    if (pcmDataBuffer.length > 0) {
                        // Â¶ÇÊûúÂâ©‰ΩôÁöÑÈááÊ†∑ÁÇπ‰∏çË∂≥‰∏ÄÂ∏ßÔºåÁî®ÈùôÈü≥Â°´ÂÖÖ
                        const samplesPerFrame = 960;
                        if (pcmDataBuffer.length < samplesPerFrame) {
                            const paddedBuffer = new Int16Array(samplesPerFrame);
                            paddedBuffer.set(pcmDataBuffer);
                            // Ââ©‰ΩôÈÉ®ÂàÜ‰∏∫0ÔºàÈùôÈü≥Ôºâ
                            encodeAndSendOpus(paddedBuffer);
                        } else {
                            encodeAndSendOpus(pcmDataBuffer.slice(0, samplesPerFrame));
                        }
                        pcmDataBuffer = new Int16Array(0);
                    }
                }
            } catch (error) {
                log(`OpusÁºñÁ†ÅÈîôËØØ: ${error.message}`, 'error');
            }
        }

        // ÂºÄÂßãÁõ¥Êé•‰ªéPCMÊï∞ÊçÆÂΩïÈü≥
        async function startDirectRecording() {
            if (isRecording) return;

            try {
                // ÂàùÂßãÂåñOpusÁºñÁ†ÅÂô®
                if (!initOpusEncoder()) {
                    log('Êó†Ê≥ïÂêØÂä®ÂΩïÈü≥: OpusÁºñÁ†ÅÂô®ÂàùÂßãÂåñÂ§±Ë¥•', 'error');
                    return;
                }

                // ËØ∑Ê±ÇÈ∫¶ÂÖãÈ£éÊùÉÈôê
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000,
                        channelCount: 1
                    }
                });

                // ÂàõÂª∫Èü≥È¢ë‰∏ä‰∏ãÊñáÂíåÂàÜÊûêÂô®
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000,
                        latencyHint: 'interactive'
                    });
                }

                // ÂàõÂª∫Èü≥È¢ëÂ§ÑÁêÜÂô®
                const processorResult = await createAudioProcessor();
                if (!processorResult) {
                    log('Êó†Ê≥ïÂàõÂª∫Èü≥È¢ëÂ§ÑÁêÜÂô®', 'error');
                    return;
                }

                audioProcessor = processorResult.node;
                audioProcessorType = processorResult.type;

                // ËøûÊé•Èü≥È¢ëÂ§ÑÁêÜÈìæ
                audioSource = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;

                audioSource.connect(analyser);
                audioSource.connect(audioProcessor);

                // ÂêØÂä®ÂΩïÈü≥
                pcmDataBuffer = new Int16Array();
                audioBuffers = [];
                totalAudioSize = 0;
                isRecording = true;

                // ÂêØÂä®Èü≥È¢ëÂ§ÑÁêÜÂô®ÁöÑÂΩïÈü≥ - Âè™ÊúâAudioWorkletÊâçÈúÄË¶ÅÂèëÈÄÅÊ∂àÊÅØ
                if (audioProcessorType === 'worklet' && audioProcessor.port) {
                    audioProcessor.port.postMessage({ command: 'start' });
                }

                // ÂèëÈÄÅÁõëÂê¨ÂºÄÂßãÊ∂àÊÅØ
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    // ‰ΩøÁî®‰∏éÊúçÂä°Á´ØÊúüÊúõÁöÑlistenÊ∂àÊÅØÊ†ºÂºè
                    const listenMessage = {
                        type: 'listen',
                        mode: 'manual',  // ‰ΩøÁî®ÊâãÂä®Ê®°ÂºèÔºåÁî±Êàë‰ª¨ÊéßÂà∂ÂºÄÂßã/ÂÅúÊ≠¢
                        state: 'start'   // Ë°®Á§∫ÂºÄÂßãÂΩïÈü≥
                    };

                    log(`ÂèëÈÄÅÂΩïÈü≥ÂºÄÂßãÊ∂àÊÅØ: ${JSON.stringify(listenMessage)}`, 'info');
                    websocket.send(JSON.stringify(listenMessage));
                } else {
                    log('WebSocketÊú™ËøûÊé•ÔºåÊó†Ê≥ïÂèëÈÄÅÂºÄÂßãÊ∂àÊÅØ', 'error');
                    return false;
                }

                // ÂºÄÂßãÈü≥È¢ëÂèØËßÜÂåñ
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                drawVisualizer(dataArray);

                // Âú®UI‰∏äÊòæÁ§∫ÂΩïÈü≥ËÆ°Êó∂Âô®
                let recordingSeconds = 0;
                const recordingTimer = setInterval(() => {
                    recordingSeconds += 0.1;
                    recordButton.textContent = `ÂÅúÊ≠¢ÂΩïÈü≥ ${recordingSeconds.toFixed(1)}Áßí`;
                }, 100);

                // ‰øùÂ≠òËÆ°Êó∂Âô®Ôºå‰ª•‰æøÂú®ÂÅúÊ≠¢Êó∂Ê∏ÖÈô§
                window.recordingTimer = recordingTimer;

                recordButton.classList.add('recording');
                recordButton.disabled = false;

                log('ÂºÄÂßãPCMÁõ¥Êé•ÂΩïÈü≥', 'success');
                return true;
            } catch (error) {
                log(`Áõ¥Êé•ÂΩïÈü≥ÂêØÂä®ÈîôËØØ: ${error.message}`, 'error');
                isRecording = false;
                return false;
            }
        }

        // ÂÅúÊ≠¢Áõ¥Êé•‰ªéPCMÊï∞ÊçÆÂΩïÈü≥
        function stopDirectRecording() {
            if (!isRecording) return;

            try {
                // ÂÅúÊ≠¢ÂΩïÈü≥
                isRecording = false;

                // ÂÅúÊ≠¢Èü≥È¢ëÂ§ÑÁêÜÂô®ÁöÑÂΩïÈü≥
                if (audioProcessor) {
                    // Âè™ÊúâAudioWorkletÊâçÈúÄË¶ÅÂèëÈÄÅÂÅúÊ≠¢Ê∂àÊÅØ
                    if (audioProcessorType === 'worklet' && audioProcessor.port) {
                        audioProcessor.port.postMessage({ command: 'stop' });
                    }

                    audioProcessor.disconnect();
                    audioProcessor = null;
                }

                // Êñ≠ÂºÄÈü≥È¢ëËøûÊé•
                if (audioSource) {
                    audioSource.disconnect();
                    audioSource = null;
                }

                // ÂÅúÊ≠¢ÂèØËßÜÂåñ
                if (visualizationRequest) {
                    cancelAnimationFrame(visualizationRequest);
                    visualizationRequest = null;
                }

                // Ê∏ÖÈô§ÂΩïÈü≥ËÆ°Êó∂Âô®
                if (window.recordingTimer) {
                    clearInterval(window.recordingTimer);
                    window.recordingTimer = null;
                }

                // ÁºñÁ†ÅÂπ∂ÂèëÈÄÅÂâ©‰ΩôÁöÑÊï∞ÊçÆ
                encodeAndSendOpus();

                // ÂèëÈÄÅ‰∏Ä‰∏™Á©∫ÁöÑÊ∂àÊÅØ‰Ωú‰∏∫ÁªìÊùüÊ†áÂøóÔºàÊ®°ÊãüÊé•Êî∂Âà∞Á©∫Èü≥È¢ëÊï∞ÊçÆÁöÑÊÉÖÂÜµÔºâ
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    // ‰ΩøÁî®Á©∫ÁöÑUint8ArrayÂèëÈÄÅÊúÄÂêé‰∏Ä‰∏™Á©∫Â∏ß
                    const emptyOpusFrame = new Uint8Array(0);
                    websocket.send(emptyOpusFrame);

                    // ÂèëÈÄÅÁõëÂê¨ÁªìÊùüÊ∂àÊÅØ
                    const stopMessage = {
                        type: 'listen',
                        mode: 'manual',
                        state: 'stop'
                    };

                    websocket.send(JSON.stringify(stopMessage));
                    log('Â∑≤ÂèëÈÄÅÂΩïÈü≥ÂÅúÊ≠¢‰ø°Âè∑', 'info');
                }

                // ÈáçÁΩÆUI
                recordButton.textContent = 'ÂºÄÂßãÂΩïÈü≥';
                recordButton.classList.remove('recording');
                recordButton.disabled = false;

                log('ÂÅúÊ≠¢PCMÁõ¥Êé•ÂΩïÈü≥', 'success');
                return true;
            } catch (error) {
                log(`Áõ¥Êé•ÂΩïÈü≥ÂÅúÊ≠¢ÈîôËØØ: ${error.message}`, 'error');
                return false;
            }
        }

        // Â§ÑÁêÜ‰∫åËøõÂà∂Ê∂àÊÅØ
        async function handleBinaryMessage(data) {
            try {
                let arrayBuffer;

                // Ê†πÊçÆÊï∞ÊçÆÁ±ªÂûãËøõË°åÂ§ÑÁêÜ
                if (data instanceof ArrayBuffer) {
                    arrayBuffer = data;
                    log(`Êî∂Âà∞ArrayBufferÈü≥È¢ëÊï∞ÊçÆÔºåÂ§ßÂ∞è: ${data.byteLength}Â≠óËäÇ`, 'debug');
                } else if (data instanceof Blob) {
                    // Â¶ÇÊûúÊòØBlobÁ±ªÂûãÔºåËΩ¨Êç¢‰∏∫ArrayBuffer
                    arrayBuffer = await data.arrayBuffer();
                    log(`Êî∂Âà∞BlobÈü≥È¢ëÊï∞ÊçÆÔºåÂ§ßÂ∞è: ${arrayBuffer.byteLength}Â≠óËäÇ`, 'debug');
                } else {
                    log(`Êî∂Âà∞Êú™Áü•Á±ªÂûãÁöÑ‰∫åËøõÂà∂Êï∞ÊçÆ: ${typeof data}`, 'warning');
                    return;
                }

                // ÂàõÂª∫Uint8ArrayÁî®‰∫éÂ§ÑÁêÜ
                const opusData = new Uint8Array(arrayBuffer);

                if (opusData.length > 0) {
                    // Êí≠ÊîæOpusÈü≥È¢ë
                    playOpusData([opusData]);
                } else {
                    log('Êî∂Âà∞Á©∫Èü≥È¢ëÊï∞ÊçÆÂ∏ß', 'warning');
                }
            } catch (error) {
                log(`Â§ÑÁêÜ‰∫åËøõÂà∂Ê∂àÊÅØÂá∫Èîô: ${error.message}`, 'error');
            }
        }

        initApp();
    </script>
</body>

</html>